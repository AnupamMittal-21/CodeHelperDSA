Stacks and Queue
################################ Implementation based Questions #################################

Implement Stack Using Arrays
  => Array lo, and one pointer at -1 initially, 
  => Push => arr[++top] = x
  => Pop => return arr[top--];


Implement Queue Using Arrays
  => Array lo, and two pointer at -1 initially, l = -1, r = -1 
  => Push => arr[rear++] = x
  => Pop => if(front<rear) return arr[front++];


Implement Stack Using Queue
  => Pop Takes O(N)
      => Simply push in q1
      => Push all the elements in q2 except the last element 

  => Push Takes O(N)
      => take q1, q2, push element in q2, then transfer elements from q1 to q2 and then swap q1,q2
      => Pop just return front of q1 

  => Using single Queue
      => Pop, If we want sigle queue, then we run loop for q.size()-1 
          and push the elements again, and remove the front. 
      => Push is simply push


Implement Queue Using Stack

Implement Stack Using Linked List
Implement Queue Using Linked List

Check For Balanced Paranthesis
Implement Min Stack




################################ Monotonic Stack ###########################################


In the monotonic stack we have sorted stack...


################################### Next Greater Element ####################################

TC: O(2N + 2N) // Extra 2N for WHILE loop as it maximally run for 2N as these are total elem in arr
SC: O(N)
we keep a stack and start from n-1 , 
if the stack is empty then we insert, 
now if the stack has some elements smaller then the current element so we remove them 
now if st has some element then the NGE will bw top of stack, else it will be -1
1 4 6 19 this is the stack. top is 1 

in case of rotated one, (NGE - II) we just iterate from 2*n-1 and update the array only when the 
i<n 

CODE: 
vector<int> nextGreaterElements(vector<int>& nums) {
    // Traverse for 2 times 
    int n = nums.size();
    stack<int> st;
    vector<int> greater(n,-1);
    int i = 2*n-1;
    while(i>=0){
        while(st.size() && nums[i%n]>=st.top()){
            st.pop();
        }
        if(st.size() && i<n){
            greater[i] = st.top();
        }
        st.push(nums[i%n]);
        i--;
    }
    return greater;
}


################## Next Smaller Element is just same as Next Greater Element #################

