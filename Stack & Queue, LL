Stacks and Queue
################################ Implementation based Questions #################################

Implement Stack Using Arrays
  => Array lo, and one pointer at -1 initially, 
  => Push => arr[++top] = x
  => Pop => return arr[top--];


Implement Queue Using Arrays
  => Array lo, and two pointer at -1 initially, l = -1, r = -1 
  => Push => arr[rear++] = x
  => Pop => if(front<rear) return arr[front++];


Implement Stack Using Queue
  => Pop Takes O(N)
      => Simply push in q1
      => Push all the elements in q2 except the last element 

  => Push Takes O(N)
      => take q1, q2, push element in q2, then transfer elements from q1 to q2 and then swap q1,q2
      => Pop just return front of q1 

  => Using single Queue
      => Pop, If we want sigle queue, then we run loop for q.size()-1 
          and push the elements again, and remove the front. 
      => Push is simply push


Implement Queue Using Stack

Implement Stack Using Linked List
Implement Queue Using Linked List

Check For Balanced Paranthesis
Implement Min Stack

################################ Conversion Questions #####################################

################################ Infix to PostFix ##########################################

if operand, add to string
if ( push to stack 
if ) then take out elements from stack and add to string till ( in stack
if operator then pop until we get lesser precedance operator then push existing 


bool isSmall(char ch1, char ch2){
    if(ch1=='('){
        return false;
    }
    if(ch1=='+' || ch1 =='-'){
        return (ch2 == '+' || ch2 =='-');
    }
    if(ch1=='*' || ch1 == '/'){
        return (ch2 != '^');
    }
    return true;
}
string infixToPostfix(string s) {
    // Your code here
    string ans = "";
    stack<char> st;
    for(auto ch:s){
        if(ch=='*' || ch == '/' || ch == '+' || ch == '-' || ch == '^'){
            while(st.size() && isSmall(st.top(), ch)){
                ans+=st.top();
                st.pop();
            }
            st.push(ch);
        }
        else if(ch=='('){
            st.push(ch);
        }
        else if(ch ==')'){
            while(st.size() && st.top()!='('){
                ans+=st.top();
                st.pop();
            }
            st.pop();
        }
        else{
            ans+=ch;
        }
    }
    while(st.size()){
        ans+=st.top();
        st.pop();
    }
    return ans;
}


################################ Infix to PostFix ##########################################


////


################################ Monotonic Stack ###########################################


In the monotonic stack we have sorted stack...


################################### Next Greater Element ####################################

TC: O(2N + 2N) // Extra 2N for WHILE loop as it maximally run for 2N as these are total elem in arr
SC: O(N)
we keep a stack and start from n-1 , 
if the stack is empty then we insert, 
now if the stack has some elements smaller then the current element so we remove them 
now if st has some element then the NGE will bw top of stack, else it will be -1
1 4 6 19 this is the stack. top is 1 

in case of rotated one, (NGE - II) we just iterate from 2*n-1 and update the array only when the 
i<n 

CODE: 
vector<int> nextGreaterElements(vector<int>& nums) {
    // Traverse for 2 times 
    int n = nums.size();
    stack<int> st;
    vector<int> greater(n,-1);
    int i = 2*n-1;
    while(i>=0){
        while(st.size() && nums[i%n]>=st.top()){
            st.pop();
        }
        if(st.size() && i<n){
            greater[i] = st.top();
        }
        st.push(nums[i%n]);
        i--;
    }
    return greater;
}


################## Next Smaller Element is just same as Next Greater Element #################



######################################             ###########################################
######################################             ###########################################
###################################### Linked List ###########################################
######################################             ###########################################
######################################             ###########################################


Every Linked List Problem, if you can't do it in LinkedList format,
copy the data in list and now your question would become for an 
array, solve it.

********** NOTE **********

In total, 
Slow and fast pointer ka socho
Reverse ka socho
Kuch naye pointers bana ke divide krne ka socho 
kuch ek ptr ko aage badhao then dono ko saath me 
yhi h bass LL me 

################# Basics ################

1 - Insertion,
2 - Deletion
3 - Delete but head is not given, so this is interesting 
        
        ListNode *nextN = node->next;
        node->val = nextN->val;
        node->next = nextN->next;

4 - Traverel 
5 - Searching

6 - Create Doubly LL
7 - Insert Node in Double LL
8 - Delete Node in Double LL

    Node* deleteNode(Node* head, int x) {
        if(head == NULL) return NULL;
        Node *temp = head;
        while(head!=NULL && x>1){ // head->data!=x
            head = head->next;
            x--;
        }
        if(head->prev){
            head->prev->next = head->next;
        }
        else{
            head->next->prev = NULL;
            temp = head->next;
        }
        if(head->next){
            head->next->prev = head->prev;
        }
        else{
            head->prev->next = NULL;
        }
        head->prev = NULL;
        head->next = NULL;
        return temp;
    }

9 - Reverse a Double LL 
    Node* reverseDLL(Node * head)
    {
        if(head == NULL)return NULL;
        
        Node *X = new Node(head->data);
        head = head->next;
        
        while(head){
            Node *temp = head->next;
            head->next = X;
            head->prev = NULL;  // Important to do, other wise TLE aayegi
            X->prev = head;
            X = head;
            head = temp;
        }
        
        return X;
    }


################################# Medium Questions ###########################################

####### 1 - Middle of LL ##############

=> Brute is find length then again iterate to n/2 elements 
=> Optimal is Tortoise & Hare Method or Slow Fast Pointers

    ListNode* middleNode(ListNode* head) {
        ListNode *slow = head, *fast = head;
        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        return slow;
    }

####### 2 - Reversing a LL ############

=> Recursion
    ListNode *fun(ListNode *head, ListNode *&newHead){
        if(head->next==NULL){
            newHead = head;
            return newHead;
        }
        ListNode * newN = fun(head->next, newHead);
        newN->next = head;
        head->next = NULL;
        return head;
    }

=> Iterative 
    ListNode* reverseList(ListNode* head) {
        if(head==NULL)return NULL;
        ListNode *X = NULL;
        while(head){
            ListNode *temp = head->next;
            head->next = X;
            X = head;
            head = temp;
        }
        return X;
    }

################## 3 - Check for cycle in LL ##########################

=> Brute: Create a map and check if the node is visited or not, so if any one is visited then
   we have cycle, NOTE: Store the node itself, not the value.


=> Using fast and slow pointers, we can start as head, and next of head, then if they meet
    it means there is cycle.

  wHY does this work? 
  => Because when slow enters in cycle we can say we stop the slow and move fast by one
  => so they are bound to meet, as it is kinda relative motion, or simply the speed of fast 
  => is 2 units whereas speed of slow is 1 unit, 
  => now, distance btw them decreases by one everytime we do a loop. 
  => Why not 3 steps and 1 step, as we need jump of 1, else we may skip 

TC = O(N)
SC = O(1)

    bool hasCycle(ListNode *head) {
        if(head==NULL || head->next == NULL)return false;
        ListNode *slow = head;
        ListNode *fast = head->next;
        // Make sure to check the condition of fast and next of fast exists, as we are doing 
        // 2 next of fast.
        while(slow!=NULL && fast!=NULL && fast->next!=NULL){
            slow = slow->next;
            fast = fast->next->next;
            if(slow==fast)return true;
        }
        return false;
    }


################## 3 - Check for cycle element in LL ##########################


################## 3 - Check for cycle Length in LL ##########################

=> Using Hashing and as we traverse we increment the count and store the count 
  return the difference in time when we got the already existing element in map

=> Using 2 pointers 


int countNodesinLoop(struct Node *head)
{
     // Code here
    if(head==NULL || head->next == NULL)return false;
    Node *slow = head;
    Node *fast = head->next;
    // Make sure to check the condition of fast and next of fast exists, as we are doing 
    // 2 next of fast.
    bool hasCycle = false;
    while(slow!=NULL && fast!=NULL && fast->next!=NULL){
        slow = slow->next;
        fast = fast->next->next;
        if(slow==fast){
            hasCycle = true;
            break;
        }
    }
    if(!hasCycle)return 0;
    slow = slow;
    fast = fast->next;
    int cnt = 1;
    while(slow!=fast){
        slow = slow->next;
        fast = fast->next->next;
        cnt++;
    }
    
    return cnt;
}


###################### Check for Palindrome ##################################################


=> Using List => Simply put all elements in a list and then iterate and see if it is palindrome,
    which also means reverse == array 

=> using Stack, traverse LL and store elements in stack, since Stack is LIFO it will store the elements in reverse order
    now traverse again in linkedList and see if it matches the top 

=> Using recursion, => As you know, if any problem you can do using stack only then you can use recursion as well ( mostly ).
    So we will have one global pointer as curr we will move this pointer once we reach the end and recursion will start from end of the list.
  
  class Solution {
      ListNode* curr;
  public:
      bool isPalindrome(ListNode* head) {
          curr = head;
          return solve(head);
      }
  
      bool solve(ListNode* head) {
          if (head == nullptr) return true;
          bool ans = solve(head->next) && head->val == curr->val;
          curr = curr->next;
          return ans;
      }
  };

=> O(1) Space => Find Middle, Reverse the second half, then compare 
    
    bool isPalindrome(ListNode* head) {
        // go to middle and then reverse the list 
        ListNode *slow = head;
        ListNode* fast = head;
        ListNode* start = head;

        while(fast && fast->next){
            fast = fast->next->next;
            slow = slow->next;
        }
        ListNode *stop = slow;
        // Now reverse from slow;
        
        ListNode *X = NULL;
        while(slow){
            ListNode* temp = slow->next;
            slow->next = X;
            X = slow;
            slow = temp;
        }

        while(X && start!=stop){
            if(X->val!=start->val)return false;
            X = X->next;
            start = start->next;
        }
        return true;
    }



############################### Segregate Even and ODD ######################################


ListNode* oddEvenList(ListNode* head) {
    if (head == nullptr || head->next == nullptr)
        return head;
        
    ListNode *odd = head, *even = head->next, *temp = even;
    int cnt = 0;
    while(even && even->next){
        odd->next = odd->next->next;
        even->next = even->next->next;
        even = even->next;
        odd = odd->next;
    }
    odd->next = temp;
    return head;
}


############################### Delete Middle element ######################################

Just keep the previous pointer and take any method to find the middle element 
and just delete the node 

################################ Delete Nth from end #######################################

Two pass => Do count Length and then again iterate len-N times
One Pass => Increment the first ptr N-1 times, now second ptr at head and move both ptrs 
          simultaneously and just delete...


################################ Intersection of Two LL ###################################

=> Stand at one node, iterate in other list if matches return, move to next
O(N^2)

=> Use Hashing and store one of the LL in map, traverse in other if this node is in Map return that
O(NlogN)

=> Reverse both the ll and then check ki kaha mil rhe h 
TC: O(N)

=> Calculate len of each and jo bada ho usse extra pointer move kro
    and then dono ko simultaneously move krao and jab same ho to return 
