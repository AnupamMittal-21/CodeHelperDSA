Stacks and Queue
################################ Implementation based Questions #################################

Implement Stack Using Arrays
  => Array lo, and one pointer at -1 initially, 
  => Push => arr[++top] = x
  => Pop => return arr[top--];


Implement Queue Using Arrays
  => Array lo, and two pointer at -1 initially, l = -1, r = -1 
  => Push => arr[rear++] = x
  => Pop => if(front<rear) return arr[front++];


Implement Stack Using Queue
  => Pop Takes O(N)
      => Simply push in q1
      => Push all the elements in q2 except the last element 

  => Push Takes O(N)
      => take q1, q2, push element in q2, then transfer elements from q1 to q2 and then swap q1,q2
      => Pop just return front of q1 

  => Using single Queue
      => Pop, If we want sigle queue, then we run loop for q.size()-1 
          and push the elements again, and remove the front. 
      => Push is simply push


Implement Queue Using Stack

Implement Stack Using Linked List
Implement Queue Using Linked List

Check For Balanced Paranthesis
Implement Min Stack

################################ Conversion Questions #####################################

################################ Infix to PostFix ##########################################

if operand, add to string
if ( push to stack 
if ) then take out elements from stack and add to string till ( in stack
if operator then pop until we get lesser precedance operator then push existing 


bool isSmall(char ch1, char ch2){
    if(ch1=='('){
        return false;
    }
    if(ch1=='+' || ch1 =='-'){
        return (ch2 == '+' || ch2 =='-');
    }
    if(ch1=='*' || ch1 == '/'){
        return (ch2 != '^');
    }
    return true;
}
string infixToPostfix(string s) {
    // Your code here
    string ans = "";
    stack<char> st;
    for(auto ch:s){
        if(ch=='*' || ch == '/' || ch == '+' || ch == '-' || ch == '^'){
            while(st.size() && isSmall(st.top(), ch)){
                ans+=st.top();
                st.pop();
            }
            st.push(ch);
        }
        else if(ch=='('){
            st.push(ch);
        }
        else if(ch ==')'){
            while(st.size() && st.top()!='('){
                ans+=st.top();
                st.pop();
            }
            st.pop();
        }
        else{
            ans+=ch;
        }
    }
    while(st.size()){
        ans+=st.top();
        st.pop();
    }
    return ans;
}


################################ Infix to PostFix ##########################################


////


################################ Monotonic Stack ###########################################


In the monotonic stack we have sorted stack...


################################### Next Greater Element ####################################

TC: O(2N + 2N) // Extra 2N for WHILE loop as it maximally run for 2N as these are total elem in arr
SC: O(N)
we keep a stack and start from n-1 , 
if the stack is empty then we insert, 
now if the stack has some elements smaller then the current element so we remove them 
now if st has some element then the NGE will bw top of stack, else it will be -1
1 4 6 19 this is the stack. top is 1 

in case of rotated one, (NGE - II) we just iterate from 2*n-1 and update the array only when the 
i<n 

CODE: 
vector<int> nextGreaterElements(vector<int>& nums) {
    // Traverse for 2 times 
    int n = nums.size();
    stack<int> st;
    vector<int> greater(n,-1);
    int i = 2*n-1;
    while(i>=0){
        while(st.size() && nums[i%n]>=st.top()){
            st.pop();
        }
        if(st.size() && i<n){
            greater[i] = st.top();
        }
        st.push(nums[i%n]);
        i--;
    }
    return greater;
}


################## Next Smaller Element is just same as Next Greater Element #################



######################################             ###########################################
######################################             ###########################################
###################################### Linked List ###########################################
######################################             ###########################################
######################################             ###########################################




################# Basics ################

1 - Insertion,
2 - Deletion
3 - Delete but head is not given, so this is interesting 
        
        ListNode *nextN = node->next;
        node->val = nextN->val;
        node->next = nextN->next;

4 - Traverel 
5 - Searching

6 - Create Doubly LL
7 - Insert Node in Double LL
8 - Delete Node in Double LL

    Node* deleteNode(Node* head, int x) {
        if(head == NULL) return NULL;
        Node *temp = head;
        while(head!=NULL && x>1){ // head->data!=x
            head = head->next;
            x--;
        }
        if(head->prev){
            head->prev->next = head->next;
        }
        else{
            head->next->prev = NULL;
            temp = head->next;
        }
        if(head->next){
            head->next->prev = head->prev;
        }
        else{
            head->prev->next = NULL;
        }
        head->prev = NULL;
        head->next = NULL;
        return temp;
    }

9 - Reverse a Double LL 
    Node* reverseDLL(Node * head)
    {
        if(head == NULL)return NULL;
        
        Node *X = new Node(head->data);
        head = head->next;
        
        while(head){
            Node *temp = head->next;
            head->next = X;
            head->prev = NULL;  // Important to do, other wise TLE aayegi
            X->prev = head;
            X = head;
            head = temp;
        }
        
        return X;
    }
