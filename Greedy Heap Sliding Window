############################## Assign Cookies ################################################

Nothing Much...
Simple Approach, as we have to assign cookies once and such that the greed[i]<=s[j]
So keep 2 pointers and whenever this condition is satisfied increment count, and both indices
if it is not satisfied, it means s[j] is less, so move the s pointer.

int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end()); sort(s.begin(), s.end());

    int i = 0, j = 0;
    int ans =0 ;
    while(i<g.size() && j<s.size()){
        if(s[j]>=g[i]){
            i++;
            ans++;
        }
        j++;
    }
    return ans;
}


################################### Lemonade Change ##########################################

Given customers comes up with 5 | 10 | 20 rupees, 
initially, we didn't have any change, so we had lemonade of 5 rupees
so how can we do so

Simple: 
if it is 5 then add the count 
if it is 10, check if we have 5's and reduce it else false
if it is 20, then check to give the first 10 and 5, if not possible try giving 5 5 5, if not return false
at the end return true;


################################### Fractional KnapSack ######################################

 static bool comp(Item &a, Item &b){
    double aRatio = a.value*(1.0);
    aRatio/=a.weight;
    double bRatio = b.value*(1.0);
    bRatio/=b.weight;
    return aRatio>bRatio;
}
// Function to get the maximum total value in the knapsack.
double fractionalKnapsack(int W, Item arr[], int n) {
    // Your code here
    sort(arr, arr+n, comp);
    
    int i =0;
    double ans = 0;
    while(W && i<n){
        if(W>arr[i].weight){
            ans+=arr[i].value;
            W-=arr[i].weight;
        }
        else{
            ans+=arr[i].value*W*(1.0)/arr[i].weight;
            W = 0;
        }
        i++;
    }
    return ans;
}


############################## Train Arrival Question Minimum Platforms ######################

Naive Approach: To find how many times a train intersects
  => Take a train, see if it intersects with how many trains, and then take the max.

TC: O(N*N)
SC: O(1)

The optimal approach is to use greedy. and sorting individually based on ending and starting time.

So combine the arrival and departure and as arrival comes, increment count, and as departure we can decrement count
ans keep taking max as ans.

int findPlatform(int arr[], int dep[], int n)
{
  vector<pair<int,int>> vec;
  
  for(int i = 0;i<n;i++){
      vec.push_back({arr[i],0});
      vec.push_back({dep[i],1});
  }
  
  sort(vec.begin(), vec.end());
  int cnt = 0, ans = 0;
  for(auto it:vec){
      if(it.second == 0)
          cnt++;
      else
          cnt--;
      ans = max(ans, cnt);
  }
  return ans;
}

TC: O(2N log 2N)
SC: O(2N)

Optimised Approach.
TC: O(2N + 2Log N)
SC: O(1)

int findPlatform(int arr[], int dep[], int n)
{	
  sort(arr, arr+n); sort(dep, dep+n);
  int i = 0, j = 0;
  
  int cnt = 0, ans = 0;
  while(i<n){
      if(arr[i]>dep[j]){
          j++;
          cnt--;
      }
      else{
          cnt++;
          i++;
      }
      ans = max(cnt, ans);
  }
  return ans;
}



################################# Valid Paranthesis ##########################################

we can do this using DP, 
Recusrive takes TC: O(3^N), SC: O(N)

f(s, idx, cnt){
  if(cnt<0) return false;
  if(idx==n) return cnt==0;
  if(s[idx]=='(') return f(s, idx+1, cnt+1);
  if(s[idx]==')') return f(s, idx+1, cnt-1);
  // ( _ ) case
  return f(s, idx+1, cnt+1) || f(s, idx+1, cnt) || f(s, idx+1, cnt-1);
}

idx, and cnt are variable so create a 2-D matrix.
TC, SC: O(N*N) using DP

bool checkValidString(string s) {
    int mini = 0;
    int maxi = 0;
    int l = 0;
    while(l<s.size()){
        if(s[l]=='('){
            mini++; maxi++;
        }
        else if(s[l]==')'){
            mini--; maxi--;
        }
        else{
            mini--;
            maxi++;
        }
        if(mini<0) mini = 0;
        if(maxi<0)return false;
        l++;
    }
    return mini==0;
}



############################## Shortest Job First ############################################

Simply just execute the smallest burst time one, and till then all the other elements will wait

long long solve(vector<int>& bt) {
    int n = bt.size();
    int ans = 0;
    sort(bt.begin(), bt.end());
    for(int i = 0;i<n;i++){
        ans+=bt[i]*(n-i-1);
    }
    return ans/n;
}

EASY PEASY

#################################### Jump Game 1 ############################################
Recursion is always a way in greedy and we can optimise using DP 

See we see at each point what is the max value we can get to now we are at i, but we can go 
only upto maxi index and we keep on updating max, 
If there are no Zeros then we will always reach destination..

bool canJump(vector<int>& nums) {
    int i = 0, maxi = 0, n = nums.size();
    while(i<n && i<=maxi ){
        maxi = max(i + nums[i], maxi);
        i++;
    }
    return maxi>=n-1;
}

#################################### Jump Game 2############################################

f(idx, jump){
  if(idx >=n-1) return jump;
  mini - INT_MAX;
  for(int i = 1;i<nums[idx])[
      mini = min(mini, fun(idx+i, jump+1);
  }
  return mini;
}

TC: O(N^N)
SC: O(N)

Use DP, 
Memoisation: TC: O(N*N)
############################ N Meetings in Room ############################################


###########################################      ############################################
###########################################      ############################################
########################################### Heap ############################################
###########################################      ############################################
###########################################      ############################################


int findKthLargest(vector<int>& nums, int k) {
    priority_queue<int, vector<int>, greater<>> minHeap;
    // priority_queue<int> maxHeap; This is Max Heap
    int n = nums.size();
    for(int i = 0;i<n;i++)
    {
        if(minHeap.size()>=k){
            if(minHeap.top()<nums[i]){  // yaha pe bass > aa jayega
                minHeap.pop();
                minHeap.push(nums[i]);
            }
        }
        else{
            minHeap.push(nums[i]);
        }
    }
    return minHeap.top();
}


###########################################      ############################################
###########################################      ############################################
##################################### Sliding Window ########################################
###########################################      ############################################
###########################################      ############################################

Some Major Categories, 

########################## Constant Window ##################################################

Eg: Given size 4 in array, and tell me maximum amount of sum we can have 
So in this case we move both the left and right pointers move ahead 
and remove element at left and add right element

1 - Assign the window 
2 - Move the window


########################### Longest SubArray | SubString with some condition ################

=> CONSECUTIVE
=> We can reduce/increase the size of the window as the condition is satisfied

=> Brute: Generate all the subarray | substring O(N*N) | => Max|Sum|Min

=> Better: Implement the sliding window, starting with window size = 1, 
    => Expand {r} => If the condition is satisfied then expand, r++;
    => Shrink {l} => when condition is not satisfied, then we shrink and do opposite of what we did, l++;
    => Code 
    l = 0, r = 0, sum = 0, maxLen =0 
    while(r<n){
        sum = sum + nums[r]
        if(sum>k){
            sum-=nums[l]
            l++;        
        }
        maxLen = max(maxLen, r-l+1)
        r++
    }
    TC: O(2*N)

=> Optimal: The problem in above approach is that we are using 2 times N, the extra one is 
    because of shrinking, so if the question is like maximum window size, then why are you shrinking, 
    just keep the window size same, and then keep moving and if size increases then do increase..
    TC: O(N)

################# Pattern 3: No of SubArrays with Some Condition ############################

Similar to pattern 2
Eg: No of subarrays with sum == k
so it is difficult to understand the conditions of shrink and expand
so we use the condition like sum<=k(x) and sum>=k(y) and then subtract ans = x-y


################## Pattern 4 Minimum Size Window with Some Condition ########################

We create a valid window and then try to shrink and check for validity
and get the answer.



################# qUESTIONS : maximum pts from start and end ##########################

isme fixed size h window ka so starting wala le lo
ab right se  badhao and left se km kro and ans ko max lete rho bass

TC: O(2K)
int maxScore(vector<int>& nums, int k) {
    int l = 0, n = nums.size(), r = n-1;
    int sum = 0;
    while(l<k){
        sum+=nums[l];
        l++;
    }
    l--;
    int ans = sum;
    while(l>=0){
        sum-=nums[l];
        sum+=nums[r];
        l--; r--;
        ans = max(ans, sum);
    }
    return ans;
}

################################ Longest Substring without repeating characters ###########

=> Brute: generate all substring : O(N^2)
simply ek map rakho and isme variable hoga length as vhi to puchi h 
ab start kro and map me daalte rho aur agar violate ho gya to reduce kro 


O(N) as we are moving R, 
isme ye remove na kr ke index store kr sakte h and agr vo exist krta h and index>=l h to hi vo
window me h, and update krna h ab 


O(N) => 
wala code, isme bass inner while loop hata dia h, to coz hme max window chaiye this
ab max mil gyi h to while l ko km mt kro bas ek se move krte chalo window ko
and jab satisfy ho jaye constraint to update ans

int longestKSubstr(string s, int k) {
    // your code here
        map<char,int> mp;
        int n = s.size();
        int l = 0, r = 0;
        
        int ans =-1;
        while(r<n)
        {
            mp[s[r]]++;
            if(mp.size()>k){
                mp[s[l]]--;
                if(mp[s[l]]==0)mp.erase(s[l]);
                l++;
            }
            if(mp.size()==k)
            ans = max(ans, r-l+1);
            r++;
        }
        return ans;
    }
