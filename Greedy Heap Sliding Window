Naive Approach: To find how many time a train is intersecting
  => Take a train and see if it is intersecting with how many train, and then take the max.

TC: O(N*N)
SC: O(1)

Optimal Approach is to use greedy. and sorting individually on the basis of ending and starting time.

So combine the arrival and departure and as arrival comes, increment count , and as departure we can decrement count
ans keep taking max as ans.

int findPlatform(int arr[], int dep[], int n)
{
  vector<pair<int,int>> vec;
  
  for(int i = 0;i<n;i++){
      vec.push_back({arr[i],0});
      vec.push_back({dep[i],1});
  }
  
  sort(vec.begin(), vec.end());
  int cnt = 0, ans = 0;
  for(auto it:vec){
      if(it.second == 0)
          cnt++;
      else
          cnt--;
      ans = max(ans, cnt);
  }
  return ans;
}

TC: O(2N log 2N)
SC: O(2N)

Optimised Approach.
TC: O(2N + 2Log N)
SC: O(1)

int findPlatform(int arr[], int dep[], int n)
{	
  sort(arr, arr+n); sort(dep, dep+n);
  int i = 0, j = 0;
  
  int cnt = 0, ans = 0;
  while(i<n){
      if(arr[i]>dep[j]){
          j++;
          cnt--;
      }
      else{
          cnt++;
          i++;
      }
      ans = max(cnt, ans);
  }
  return ans;
}



############### Valid Paranthesis 
we can do this using DP, 
Recusrive takes TC: O(3^N), SC: O(N)

f(s, idx, cnt){
  if(cnt<0) return false;
  if(idx==n) return cnt==0;
  if(s[idx]=='(') return f(s, idx+1, cnt+1);
  if(s[idx]==')') return f(s, idx+1, cnt-1);
  // ( _ ) case
  return f(s, idx+1, cnt+1) || f(s, idx+1, cnt) || f(s, idx+1, cnt-1);
}

idx, and cnt are variable so create a 2-D matrix.
TC, SC: O(N*N) using DP

bool checkValidString(string s) {
    int mini = 0;
    int maxi = 0;
    int l = 0;
    while(l<s.size()){
        if(s[l]=='('){
            mini++; maxi++;
        }
        else if(s[l]==')'){
            mini--; maxi--;
        }
        else{
            mini--;
            maxi++;
        }
        if(mini<0) mini = 0;
        if(maxi<0)return false;
        l++;
    }
    return mini==0;
}

