############################# Assign Cookies ################################################

Nothing Much...
Simple Approach, as we have to assign cookies once and such that the greed[i]<=s[j]
So keep 2 pointers and whenever this condition is satisfied increment count, and both indices
if it is not satisfied, it means s[j] is less, so move the s pointer.

int findContentChildren(vector<int>& g, vector<int>& s) {
    sort(g.begin(), g.end()); sort(s.begin(), s.end());

    int i = 0, j = 0;
    int ans =0 ;
    while(i<g.size() && j<s.size()){
        if(s[j]>=g[i]){
            i++;
            ans++;
        }
        j++;
    }
    return ans;
}


############################# Lemonade Change ##########################################

Given customers comes up with 5 | 10 | 20 rupees, 
initially, we didn't have any change, so we had lemonade of 5 rupees
so how can we do so

Simple: 
if it is 5 then add the count 
if it is 10, check if we have 5's and reduce it else false
if it is 20, then check to give the first 10 and 5, if not possible try giving 5 5 5, if not return false
at the end return true;


############################## Fractional KnapSack ######################################

 static bool comp(Item &a, Item &b){
    double aRatio = a.value*(1.0);
    aRatio/=a.weight;
    double bRatio = b.value*(1.0);
    bRatio/=b.weight;
    return aRatio>bRatio;
}
// Function to get the maximum total value in the knapsack.
double fractionalKnapsack(int W, Item arr[], int n) {
    // Your code here
    sort(arr, arr+n, comp);
    
    int i =0;
    double ans = 0;
    while(W && i<n){
        if(W>arr[i].weight){
            ans+=arr[i].value;
            W-=arr[i].weight;
        }
        else{
            ans+=arr[i].value*W*(1.0)/arr[i].weight;
            W = 0;
        }
        i++;
    }
    return ans;
}


########################## Train Arrival Question Minimum Platforms ######################

Naive Approach: To find how many times a train intersects
  => Take a train, see if it intersects with how many trains, and then take the max.

TC: O(N*N)
SC: O(1)

The optimal approach is to use greedy. and sorting individually based on ending and starting time.

So combine the arrival and departure and as arrival comes, increment count, and as departure we can decrement count
ans keep taking max as ans.

int findPlatform(int arr[], int dep[], int n)
{
  vector<pair<int,int>> vec;
  
  for(int i = 0;i<n;i++){
      vec.push_back({arr[i],0});
      vec.push_back({dep[i],1});
  }
  
  sort(vec.begin(), vec.end());
  int cnt = 0, ans = 0;
  for(auto it:vec){
      if(it.second == 0)
          cnt++;
      else
          cnt--;
      ans = max(ans, cnt);
  }
  return ans;
}

TC: O(2N log 2N)
SC: O(2N)

Optimised Approach.
TC: O(2N + 2Log N)
SC: O(1)

int findPlatform(int arr[], int dep[], int n)
{	
  sort(arr, arr+n); sort(dep, dep+n);
  int i = 0, j = 0;
  
  int cnt = 0, ans = 0;
  while(i<n){
      if(arr[i]>dep[j]){
          j++;
          cnt--;
      }
      else{
          cnt++;
          i++;
      }
      ans = max(cnt, ans);
  }
  return ans;
}



############### Valid Paranthesis 
we can do this using DP, 
Recusrive takes TC: O(3^N), SC: O(N)

f(s, idx, cnt){
  if(cnt<0) return false;
  if(idx==n) return cnt==0;
  if(s[idx]=='(') return f(s, idx+1, cnt+1);
  if(s[idx]==')') return f(s, idx+1, cnt-1);
  // ( _ ) case
  return f(s, idx+1, cnt+1) || f(s, idx+1, cnt) || f(s, idx+1, cnt-1);
}

idx, and cnt are variable so create a 2-D matrix.
TC, SC: O(N*N) using DP

bool checkValidString(string s) {
    int mini = 0;
    int maxi = 0;
    int l = 0;
    while(l<s.size()){
        if(s[l]=='('){
            mini++; maxi++;
        }
        else if(s[l]==')'){
            mini--; maxi--;
        }
        else{
            mini--;
            maxi++;
        }
        if(mini<0) mini = 0;
        if(maxi<0)return false;
        l++;
    }
    return mini==0;
}

