########## Code for BFS ###########
########## Code for DFS ###########
########## Code for Topo Sort (BFS) (Kahn's Algorithm) ###########
########## Code for Topo Sort (DFS) ###########
########## Code for Topo Sort (DFS) For checking Cycle in Directed Graph ###########
########## Code For checking Cycle in (Un)Directed Graph using BFS | DFS ###########
########## BFS | DFS on Grids questions (0/1 Matrix)  ###########
########## BFS | DFS on Grids questions but with reverse approach ###########
########## BFS | DFS on Grids questions Word Ladder ##########
########## BFS | DFS Coloring Problem (Bipartite) ##########
########## Questions on BFS | DFS ##########
########## Questions on Topo Sort ##########



########################################### Code for BFS #####################################################################################
TC: O(V+E)
SC: queue (O(E))


vector<int> bfsOfGraph(vector<vector<int>> &nums) {
    int n = nums.size();
    vector<vector<int>> adj(n);

    // This is for creating an adjacency list from the adjacency matrix.
    for(int i = 0;i<n;i++){
        for(int j =0;j<n;j++){
            if(i!=j && nums[i][j]==1){
                adj[i].push_back(j);
                adj[j].push_back(i);
            }
        }
    }

    // Creating adjacency list from edges.
    for(auto it:edges){
        int u = edges[0];
        int v = edges[1];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }

    int cnt = 0;
    vector<int> ans, vis(n,0);
    queue<int> q;
   
    for(int i =0;i<n;i++){
        if(!vis[i]){
            q.push(i);
            vis[i]=1;

            while(!q.empty()){
                int curr = q.front();
                q.pop();
                ans.push_back(curr);
                
                for(auto it:adj[curr]){
                    if(!vis[it]){
                        vis[it] =1;
                        q.push(it);
                    }
                }
            }
            cnt++;
        }
    }
    return ans;
}


########################################### Code for DFS #############################################################################
TC: O(V+E)
SC: queue (O(E))


void dfs(int node, vector<int> &ans, vector<int> &vis, vector<int> adj[]){
    vis[node]=1;
    ans.push_back(node);
    for(auto it:adj[node]){
        if(!vis[it]){
            dfs(it,ans,vis,adj);
        }
    }
}


########################################### Code for Topo Sort (BFS) (Kahn's Algorithm) #################################################
TC: O(V+E)       (Same as BFS)
SC: queue (O(E))


vector<int> topoSort(int V, vector<vector<int>> &adj) 
{
   // Create indegree
   vector<int> indegree(V, 0);
    for(int i = 0;i<V;i++){
        for(auto it: adj[i]){
            indegree[it]++;
        }
    }
    
    queue<int> q;
    
    // Search for the ones with 0 indegree and push them in the queue.
    for(int i = 0;i<V;i++){
       int it = indegree[i];
       if(it==0){
           q.push(i);
       }
    }
   
    vector<int> ans;
    
    while(q.size()){
       int curr =  q.front();
       q.pop();
       
       for(auto it:adj[curr]){
           indegree[it]--;
           if(indegree[it]==0){
               q.push(it);
           }
       }
       ans.push_back(curr);
    }
    return ans;
    // Checking cycle in Directed Graph if ans.size()!=V then cycle exists.
}


########################################### Code for Topo Sort (DFS) ########################################################################
TC: O(V+E)       (Same as DFS)
SC: queue (O(E))


void dfs(int v,vector<int> adj[], stack<int> &st, vector<int> &vis){
    vis[v]=1;
    for(int i = 0;i<adj[v].size();i++){
        if(vis[adj[v][i]]==-1){
            dfs(adj[v][i],adj,st,vis);
        }
    }
    st.push(v);
}

//Function to return the list containing vertices in Topological order. 
vector<int> topoSort(int V, vector<int> adj[]) 
{
    vector<int> vis(V,-1);
    stack<int> st;

    // Simple DFS with a stack. 
    for(int i =0;i<V;i++){
        if(vis[i]==-1){
            dfs(i,adj,st,vis);
        }
    }

    vector<int> ans;
    while(!st.empty()){
        ans.push_back(st.top());
        st.pop();
    }
    return ans;
}


#################################### Code for Topo Sort (DFS) For checking Cycle in Directed Graph ############################################


bool dfs(int node, vector<int> &vis, vector<int> &pathVis, vector<int> adj[]){
    vis[node] = 1;
    pathVis[node] = 1;
    
    for(auto it:adj[node]){
        if(!vis[it]){
            if(dfs(it, vis, pathVis, adj)==true)return true;
        }
        else if(pathVis[it]==1){
            return true;
        }
    }
    pathVis[node] = 0;
    return false;
}
// Function to detect cycle in a directed graph.
bool isCyclic(int V, vector<int> adj[]) {

    vector<int> pathVis(V,0), vis(V,0);

    for(int i = 0;i<V;i++){
        if(!vis[i]){
            if(dfs(i, vis, pathVis, adj)==true)return true;
        }
    }
    return false;
}


#################################### Code For checking Cycle in (Un)Directed Graph using BFS | DFS ############################################

=> Keep track of Parent, and if it is a parent then continue, if it is visited then return True, and if it is not visited then visit and put in queue or call recursive function.

bool dfs(int node, int parent, vector<int> &vis, vector<int> adj[]){
    vis[node]=1;
    for(auto it:adj[node]){
        if(it==parent)continue;
        if(!vis[it]){
            if(dfs(it,node,vis,adj))return true;
        }
        else return true;
    }
    return false;
}

bool bfs(int node, int parent, vector<int> &vis, vector<int> adj[]){
    queue<pair<int,int>> q;
    
    q.push({node, parent});
    
    while(q.size()){
        pair<int, int> curr_pair = q.front();
        q.pop();
        
        int curr = curr_pair.first;
        int par = curr_pair.second;
        
        for(auto it:adj[curr]){
            if(it==par)continue;
            if(vis[it]==1){
                return true;
            }
            vis[it] = 1;
            q.push({it,curr});
        }
        
    }
    return false;
        
}   


#################################### BFS | DFS on Grids questions (0/1 Matrix) ############################################

=> 0/1 Matrix ques. This is a standard template for grids and BFS/DFS
=> Store all zeros in the queue and then start BFS to keep track of the distance store it in the queue and keep on increasing inside iterating in adjacancy.


class Solution {
    bool valid(int i, int j, int n, int m){
        return i>=0 && i<n && j>=0 && j<m;
    }

    void dfs(int node, vector<int> &ans, vector<int> &vis, vector<int> adj[]){
    vis[node]=1;
    ans.push_back(node);
    for(auto it:adj[node]){
        if(!vis[it]){
            dfs(it,ans,vis,adj);
        }
    }
}


public:
    vector<vector<int>> updateMatrix(vector<vector<int>>& grid) {
        queue<pair<int,pair<int,int>>> q;
        int n = grid.size();
        int m = grid[0].size();        
        vector<vector<int>> vis(n,vector<int>(m,0)), dist(n,vector<int>(m,INT_MAX));

        for(int i = 0;i<n;i++){
            for(int j = 0;j<m;j++){
                if(grid[i][j]==0){
                    q.push({0,{i,j}});
                    vis[i][j] = 1;
                    dist[i][j] = 0;
                }
            }
        }

        int x[] = {0,0,1,-1};
        int y[] = {-1,1,0,0};


        while(q.size()){
            pair<int,pair<int,int>> curr_pair = q.front();
            q.pop();

            int dis = curr_pair.first;
            int i = curr_pair.second.first;
            int j = curr_pair.second.second;

            for(int k = 0;k<4;k++){
                int new_i = i+x[k];
                int new_j = j+y[k];

                if(valid(new_i, new_j, n,m)){
                    if(grid[new_i][new_j]==1 && !vis[new_i][new_j]){
                        int new_dist = min(dist[new_i][new_j], dis+1);
                        dist[new_i][new_j] = new_dist;
                        vis[new_i][new_j] = 1;
                        q.push({dis+1,{new_i,new_j}});
                    }
                }
            }
        }
        return dist;
    }
};


#################################### BFS | DFS on Grids questions but with reverse approach  ############################################
=> TC: O(N*M)
=> SC: O(N*M) Generally same for most of the matrix problems.
=> (No. of Enclaves | Surrounded regions)
=>  So, we start with considering everything in the answer and start from edges, start the DFS | BFS, and mark all the reachable nodes in the answer array.


class Solution {
    bool valid(int i, int j, int n, int m){
        return i>=1 && i<n-1 && j>=1 && j<m-1;
    }

    void dfs(int i, int j, vector<vector<int>> &ans, vector<vector<int>> &vis, vector<vector<int>>& grid){
        int x[] = {0,0,1,-1};
        int y[] = {-1,1,0,0};
        int n = grid.size();
        int m = grid[0].size();   
        vis[i][j] = 1;
        ans[i][j] = 1;
        for(int k= 0 ; k<4; k++){
            int new_i = x[k] + i;
            int new_j = y[k] + j;
            if(valid(new_i,new_j,n,m) && grid[new_i][new_j]==1 && !vis[new_i][new_j]){
                dfs(new_i,new_j,ans,vis, grid);
            }
        }
    }
public:
    int numEnclaves(vector<vector<int>>& grid) {
        queue<pair<int,int>> q;
        int n = grid.size();
        int m = grid[0].size();        
        vector<vector<int>> vis(n,vector<int>(m,0));
        vector<vector<int>> ans(n,vector<int>(m,0));

        for(int i = 0;i<n;i++){
            if(grid[i][0]==1){
                if(!vis[i][0]){
                    dfs(i,0,ans,vis, grid);
                }
            }
            if(grid[i][m-1]==1){
                if(!vis[i][m-1]){
                    dfs(i,m-1,ans,vis, grid);
                }
            }
        }
        for(int i = 0;i<m;i++){
            if(grid[0][i]==1){
                if(!vis[0][i]){
                    dfs(0,i,ans,vis, grid);
                }
            }
            if(grid[n-1][i]==1){
                if(!vis[n-1][i]){
                    dfs(n-1,i,ans,vis, grid);
                }
            }
        }
        int cnt= 0;

        for(int i = 0;i<n;i++){
            for(int j = 0;j<m;j++){
                if(grid[i][j]==1 && ans[i][j]==0)cnt++;
            }
        }
        return cnt;
    }
};


#################################### BFS | DFS on Grids questions Word Ladder ############################################


int ladderLength(string startWord, string targetWord, vector<string>& wordList) {
        
    // Creation of Graph...
    queue<pair<string, int>> q;
    q.push({startWord, 1});

    unordered_set<string> st(wordList.begin(), wordList.end());
    st.erase(startWord);

    while (!q.empty())
    {
        string word = q.front().first;
        int steps = q.front().second;
        q.pop();
        
        if (word == targetWord)
            return steps;

        for (int i = 0; i < word.size(); i++)
        {
            char original = word[i];
            for (char ch = 'a'; ch <= 'z'; ch++)
            {
                word[i] = ch;
                if (st.find(word) != st.end())
                {
                    st.erase(word);
                    q.push({word, steps + 1});
                }
            }
            word[i] = original;
        }
    }
    return 0;
}


#################################### BFS | DFS Coloring Problem (Bipartite) ####################################################################################

TC = O(V + 2*E) for Undirected graph DFS | BFS 


bool dfs(int node, int col, int color[], vector<int> adj[]) {
    color[node] = col; 
    
    // traverse adjacent nodes
    for(auto it : adj[node]) {
        // if uncoloured
        if(color[it] == -1) {
            if(dfs(it, !col, color, adj) == false) return false; 
        }
        // if previously coloured and have the same colour
        else if(color[it] == col) {
            return false; 
        }
    }
    
    return true; 
}

#################################### Questions on BFS | DFS ####################################################################################
TC = O(V + 2*E) for Undirected graph DFS | BFS 

1 - Rotting Oranges,
    => Since this is a matrix and we are allowed to move in 4 directions the concept is the same as BFS, the only difference is
        that we have to create x and y arrays. and make sure to make a queue that has I, J, and cur_cnt. 
        Also, consider that we are not sure of the connected components. (Level Wise - BFS)
    => Why BFS because we have to move all together to get the minimum time to rot all the oranges. 
    => Always remember that in the case of matrix graph questions, we can always optimize space by changing in the given matrix like set value = -1 for visited and so on.
    
2 - Flood Fill Algorithm, Given a starting row and column we have to fill the connected pixels with a color.
    => This can be solved using BFS | DFS.
    => Simply just start with the given pixel put them in the queue and start traversing in 4 directions if the value is the same as the current node then keep on doing traversal
        and make sure to keep a new matrix in which changes are made.
    
3 - 0/1 Matrix, we have to find the distance of the nearest 0 from each cell.
    => Why BFS because we have to move all together to get the minimum distance from 0.
    => Store all zeros in the queue and then start BFS to keep track of the distance store it in the queue and keep on increasing inside iterating in adjacency.

4 - No. of Enclaves | Surrounded regions
    => The important thing in this question is that we need to approach this using reverse thinking.
    => We have to find the ones that are at the corner so all connected can't be considered in our answer.
    => So, we start with considering everything in the answer and start from edges, start the DFS | BFS, and mark all the reachable nodes in the answer array.

5 - Word Ladder - 1, Given a starting word, the ending word, and words, so change any one character and then tell the minimum steps to create the ending word.
    => So we need to first think of converting this to a graph as there are multiple options, as converting itself we can add code to do BFS and get the minimum changes.
    => Why BFS?, Because we need minimum length, so we have to keep a counter and do simultaneously through all the paths, and when we reach the ending word we just return the count.
    => In this you have to make an adjacency list, so we iterate over the length of words and then from 'a' to 'z', 
        and if the new word exists in the set, we erase the word from the set and push in the queue with an increase in level.

6 - Word Ladder - 2, Store all the minimum length sequences.
    => We are going to store the sequence in the queue, so the queue is storing the vector. And we don't erase elements now, we will erase them after completing the level.

7 - Bipartite Graph, Coloring methods If you can color the graph using 2 colors and adjacent have an alternate color.
    => Start with 2 sets and push node and flag in the queue, now while traversing in adjacency make sure to check whether the neighbor doesn't exist in the same set, if it does, return false right away.
    => Another approach is that any graph with a cycle of length odd can never be a BiPartite graph.
    => So keep a color array and keep on traversing and coloring the adjacent nodes with the opposite color of the parent,
        if it is already colored then return False.
    => BFS | DFS can both work.

8 - Identical Islands,
    => Simple BFS | DFS, just keep in mind that we have to make sure that the pattern is matched, and we get the unique, so set is there for this task.
    => Now, subtract the base from all the adjacent nodes so that they become relative and the set can work properly.
    => TC: O(n*m*log(n*m))


#################################### Questions on Topo Sort ####################################################################################

1 - Course Schedule, 
    => Simply apply any Topo Sort (BFS|DFS).

2 - Eventual States, means those node that reaches the terminal(Outdegree==0) nodes. 
    => So, BFS In Kahn standard algo, automatically stores valid answers.
    => In DFS we take a marked array as vis and pathVis are for cycle detection and marked will tell if at any stage we are returning due to cycle then mark it False.

3 - Alien Dictionary, strings are given in ascending order, we have to find the dictionary out of it.
    => So, Simply compare the words create a graph, and apply Standard TopoSort.
    => abad, aba this is not a valid dictionary as the initial one should be small.
    => Another example is cyclic dependency like "aba", "baf", abe now it says a<b<a and it is not possible.



#################################### Shortest Path Algorithms #######################################################################


#################################### Single Source Shortest Path Algorithm: Bellman Ford Algorithm #######################################################################
TC: O(V*E)
=> Why need Bellman Ford? Because Dijkstra fails on negative weights and negative cycles. As it keeps on minimising the weights and results in TLE 
=> It is Applicable only on Directed Graphs, so if we have an undirected graph, make a directed edge from u to v and v to u with the same weight.
=> Also This algorithm is used to detect negative cycles (The total edge weights of a cycle are negative).
=> Relax all the edges n-1 sequentially. In each relaxation, we go across each edges and relax them.
=> Why exactly (n-1) iterations? (Edges can be in any order) because in worst case you will take n-1 edges to reach from first to last
=> Now if after n-1 relaxation in nth iteration the weights change then it has a negative cycle.


vector<int> bellman_ford(int n, vector<vector<int>>& edges, int S) {
    vector<int> dist(n,1e8);
    dist[S] = 0;
    for(int i = 0;i<n-1;i++){
        for(auto edge:edges){
            int u = edge[0];
            int v = edge[1];
            int wt= edge[2];
            
            if(dist[u]!=1e8 && dist[u] + wt < dist[v]){
                dist[v] = dist[u] + wt;
            }  
        }
    }
    for(auto edge:edges){
        int u = edge[0];
        int v = edge[1];
        int wt= edge[2];
        
        if(dist[u]!=1e8 && dist[u] + wt < dist[v]){
            return {-1};
        }  
    }
    return dist;
}


#################################### Multi-Source Shortest Path Algorithm: Floyd Warshal Algorithm #######################################################################
TC: O(V*E)
=> Works fine even for negative weights.
=> Go via every node and try. 0->1 = 0->1 + 1->0, so this is the intuition behind this algorithm.
=> Min(dist[I][k] + dist[k][j]) => this is Dynamic programming concept. because we need precomputation.
=> In this we use an adjacency matrix for computation.
=> If this is undirected then make it directed.
 
