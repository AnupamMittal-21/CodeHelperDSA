CP

min Heap....
priority_queue <int, vector<int>, greater<int> > pq;

#include <iostream>
#include<bits/stdc++.h>

using namespace std;

int main() {
    int T;
    cin>>T;
    for(int la = 0;la<T;la++)
    {
        int n,y;
        cin>>n>>y;
        for(int i =0;i<n;i++){
            
        }
        if(x+y>6)cout<<"YES"<<endl;
        else cout<<"NO"<<endl;
    }
	// your code goes here
	return 0;
}
###################################################################################
###################################################################################

void print(vector<int>array) {
   int size = array.size();
   for(int i = 0; i<size; i++)
      cout << array[i] << " ";
   cout << endl;
}

###############################

2-D for loop print 

void print(vector<vector<int>>array) {
    int n = array.size();
    for (int i = 0; i < n; i++) {
       for (int j = 0; j < n; j++) {
         cout << array[i][j]<<" ";
       }
       cout<<endl;
    }
}
    

###################################################################################


// for loop
for (int i = 0; i < nums.size(); i++) {
  cout << i;
}

// 2-D for loop
for (int i = 0; i < nums.size(); i++) {
  for (int j = 0; j < nums.size(); j++) {
    cout << nums[i][j];
  }
}

//while loop
int i = 0;
while (i <= n) {
  cout << i << " ";
  i++;
}

###################################################################################


//Linear search
int search(int arr[], int n, int x)
{
    int i;
    for (i = 0; i < n; i++)
        if (arr[i] == x)
            return i;
    return -1;
}


###############################


// Binary search
int binarySearch(int arr[], int l, int r, int x)
{
    if (l <= r) 
    {
        int mid = l + (r - l) / 2;
        if (arr[mid] == x)
            return mid;
        if (arr[mid] > x)
            return binarySearch(arr, l, mid - 1, x);
        return binarySearch(arr, mid + 1, r, x);
    }
    return -1;
}

###############################


// Iteration -  binary search
int binarySearch(int arr[], int l, int r, int x)
{
    while (l <= r) 
    {
        int m = l + (r - l) / 2;
        if (arr[m] == x)
            return m;
        if (arr[m] < x)
            l = m + 1;
        else
            r = m - 1;
    }
    return -1;
}

###################################################################################


//recursion code with memoization
int cnt=0;
int f(vector<vector<int>> &dp, int i , int j,int n,int m){
    if(i>=n || j>=m)return 0;
    if(i==n-1 || j==m-1){
        cnt++;
        return 1;
    }
    if(dp[i][j]!=-1){cnt++;return dp[i][j];}
    int a,b;
    a =f(dp,i+1,j,n,m);
    b =f(dp,i,j+1,n,m);
    dp[i][j]=a+b;
    return dp[i][j];
}


###################################################################################


//In order Traversal of binary tree
// Recursive Approach
void fun(TreeNode* root, vector<int> &ans){
     if(root==NULL)return;
     fun(root->left,ans);
     ans.push_back(root->val);
     fun(root->right,ans);
 }

###############################

 // without recursion
 void inorderLinear(TreeNode* root, vector<int> &ans){
     stack<TreeNode *> st;
     TreeNode *curr=root;
     while(true){
         if(curr!=NULL){
             st.push(curr);
             curr=curr->left;
         }
         else if(!st.empty()){
             TreeNode *temp = st.top();
             ans.push_back(temp->val);
             st.pop();
             curr=temp->right;
         }
         else if(st.empty())break;
     }
 }


###################################################################################


// Level Order Traversal of Binary Tree (BFS)
vector<vector<int>> levelOrder(TreeNode* root) {
     queue<TreeNode *> q;
     q.push(root); 
     q.push(NULL);
     vector<vector<int>> ans;
     if(root==NULL){return ans;}
     vector<int> temp;
     while(!q.empty()){       
         TreeNode * node=q.front();
         q.pop();
         if(node!=NULL){
             temp.push_back(node->val);
             if(node->left!=NULL){q.push(node->left);}
             if(node->right!=NULL){q.push(node->right);}
         }
         else{
             ans.push_back(temp);
             temp.resize(0);
             if(!q.empty()){q.push(NULL);}
         }
     }
     return ans;
 }


###################################################################################


//(BFS of a GRAPH)
vector<int> bfsOfGraph(int V, vector<int> adj[]) {
     queue<int> q;
     vector<int> ans;
     vector<bool> vis(V,0);
     q.push(0);
     vis[0]=1;
     while(!q.empty()){
         int a = q.front();
         ans.push_back(a);
         q.pop();
         for(auto it:adj[a]){
             if(!vis[it]){
                 vis[it]=1;
                 q.push(it);
             }
         }
     }
     return ans;
 }

###############################

//DFS of A GRAPH 
vector<int> dfsOfGraph(int V, vector<int> adj[]) {
  vector<int> ans;
  vector<bool> vis(V,0);
  dfs(ans,adj,0,vis);
  return ans;
}
void dfs(vector<int> &ans,vector<int> adj[],int root,vector<bool> &vis){
  ans.push_back(root);
  vis[root]=1;
  for(auto it:adj[root]){
      if(!vis[it])
          dfs(ans,adj,it,vis);
  }
}


###################################################################################


No of provinces, bfs graph 1 D
int findCircleNum(vector<vector<int>>& nums) {
  int n = nums.size();
  vector<vector<int>> adj(n);
  for(int i = 0;i<n;i++){
      for(int j =0;j<n;j++){
          if(i!=j && nums[i][j]==1){
              adj[i].push_back(j);
              adj[j].push_back(i);
          }
      }
  }
  int cnt = 0;
  vector<char> vis(n,false);
  queue<int> q;
  for(int i =0;i<n;i++){
      if(!vis[i]){
          q.push(i);
          vis[i]=true;
          while(!q.empty()){
              int a = q.front();
              q.pop();
              for(auto it:adj[a]){
                  if(!vis[it]){
                      q.push(it);
                      vis[it]=true;
                  }
              }
          }
          cnt++;
      }
  }
  return cnt;
}

###################################################################################

No of provinces, bfs graph 2 D
void bfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>grid){
  int n=grid.size();
  int m=grid[0].size();
  vis[row][col]=1;

  queue<pair<int,int>>q;
  q.push({row,col});
  while(!q.empty()){
      int row=q.front().first;
      int col=q.front().second;
      q.pop();
      // traversing the neighbours of {row,col}.
      for(int delrow=-1;delrow<=1;delrow++){
          for(int delcol=-1;delcol<=1;delcol++){
              if(abs(delrow)+abs(delcol)==2)continue; //continue for diagonal neighbours
              int nrow=row+delrow;
              int ncol=col+delcol;
              if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && !vis[nrow][ncol] && grid[nrow][ncol]=='1'){
                      vis[nrow][ncol]=1;
                      q.push({nrow,ncol});
              }
          }
      }
  }
}
int numIslands(vector<vector<char>>& grid) {
  int n=grid.size();
  int m=grid[0].size();
  int ans=0;
  vector<vector<int>>vis(n,vector<int>(m,0));
  for(int i=0;i<n;i++){
      for(int j=0;j<m;j++){
          if(!vis[i][j] && grid[i][j]=='1'){
              bfs(i,j,vis,grid);
              ans++;
          }
      }
  }
  return ans;
}


###################################################################################


// do-while loop
int price = 300;
do {
  std::cout << "Too expensive!";
} while (price > 500);

// for-each loop
int fibonacci[5] = { 0, 1, 1, 2, 3 };
for (auto number:fibonacci){
  std::cout << number;
}
