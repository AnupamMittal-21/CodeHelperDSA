notes from Love Babbar DBMS word file me h 


Modern Databases
Key value db 
Redis hota h 
like js objects pyhton dict 

redis -> set user:23:bio "isfaj"
get user:23:bio 

DB server me ram me store hota h  (stores on disk)
they are very fast but has limited space 
no querying , no joinds

caching/pub/sub/leaderboards usecase 


Wide column cassandra, hbase
can handle unstructures, 
scaling aasan 
decentrailsed so hori scaling is easy

freq write 




Triggers in DBMS 

automatically code run after/before some condition 
eg sending email on registering new users 

Create Trigger trigger_name 
(before | after)
INsert | update | delte 
on table_name
[for each row | for each column ]
[trigger body]



eg:
create trigger sample_trigger 
before insert on students
for each row
set new.marks = new.marks+6;

Nested Ttrigger 
infinite loop lag sakta h to sahi se use kro 
operations in trigger 

drop: remove trigger from db
DROP TRIGGER trigeer_name ;
show: 
SHOW TRIGGERS IN db_name;
insert : 
before : update or validate recodrd before saved to db


Create trigger trigger_name 
after INSERT
on student
for each row
insert into final_mark values(new.marks);



STORED PROCEDURES: 
piece of code that we use more often 
mtlb function type hi samajh lo ki bass call kr dia 
baar baar 

DELIMITER $$  becoz ; milte hi vo stop ho jata h to hmne temporarily change kr dia 
CREATE PROCEDURE get_cust()
BEGIN
 SELECT * FROM customers;
END $$
DELIMITER ;


invoke ke liye
CALL get_cust();
CALL get_cust()

DROP get_cust;

DELIMITER $$
CREATE get_cust(IN id INT, IN f_name VARCHAR(50))
BEGIN
  SELECT * FROM STU where Cust_id = id AND 
  f_name = f_name;
END $$
DELIMITER ;

CALL find_cust(1, "larry");


reduces network traffic
increases performance
control 

create table stu(empID varchar(255), fname varchar(33), 
id INT primary key auto increment);

select empId, TRIM(empID) as IDTRim 
from emp;
dono end se spaces hata dega 
, REPLACE(lastName, '-Fired', '') as LAST

, start, length  hota h isme 
SUBSTRING(firstName, 1, 3)
1 se start hoke 3 char 
indexing string ki 1 se hi hoti h isme 


SELECT DISTINCT


Document based : Mongo db, firestore, dynamo db
ye ache h stable and reliable 
no schema , collections hote h . heiracthy
no joins 

read fast/ write slow



System design ke liye dbms 

Caching => Redis 
video, audio vghr => blob storages => Amazon S3 + CDN => distribution ke ;iye 
accross the globe baatne ke liye 

seller , amazon types : searching vghr ke liye 
Text search enginfe, elastic search, solar 

airportt search kra, galat spell pe bhi to edit distance, me fuzziness dalte h 

ye search engine h, 
db me hota h ki data loss nhi hoga 

matrix vghr time series databases use krte h t1. t2 me append hoga 
openTS db use krenge 

bhut bada data h, amazon ka and analysis chaiyeh 
to use krenge big data concept, data warehouse, hadoop  use kro 

structured h to relational use kro, 
need acid then RDBMS (oracle sql server, MS sql. mysql, postgres), 

catalogue types to use document types eg mongodb, couch base, 
isme raad and query dono ache hote h 
bhut sare data types h 

ever increasing data, h to use columnar db, cassandra , HBase 
and less query 



INDEXING 

see, koi bhi query krte h to hme vo data Secondary storage se lana hota h 
and usko phle ram me load krenge tab uspe cpu search kr sakega
but ram me laate h hm blocks 
maan lo block size = 100 , so ek i/o me 100 records aaye and unpe search hua 
ab mil gya to hit, bhi to miss,s and swap hoga next block see 

now indexing se hm ye i/o wali cheez reduce krte h 
means hm no of block in / out reduce krte  h 

searching time to lagega hi utn a 

Now sparse tabhi lagegi agar vo ordered h to, nhi to dense lagegi 

types of indexing 

1 - Primary 
clustered 
secondary 

ordered file => Primaary index | Clustered Index
Unordeed file > Secondary Index| Secondaey index
                -> Key         | Non Key 


primary key lagai h to oracle ya sql me automatically primary key lag jati h 
to isme sparse ban sakti h indexing 

harr block ke liye ek entry hoti h sparse me 
dense me no of entreies = no of records total walw 
log2N + 1 itna TC h 


Clustered index, 
lik1 
1 
1
1
2
2
3
3
3
3
3
3
3 h to 
1 ke liye ek pointer
2 ke liye ek pointerr aisa kuch kr sakte h 
but ho sakta h ki 1 ek block me na fit ho
to block hanker, use hoga 
mtlb ki agle block me bhi krte raho 

Sparse banega 


Atmost 1 primary ya clustered bante h


Secondary means 
ki jese ID pe primary index laga diya h 
ab laga rhe h PAN Number pe 
and ye hmesha dense hoga coz ek block ko represeent nhi kr sakte aise 

key type h to vo indexing wale table me to sorted lag sakte h 

aur non key h to ek Name_1 ka ek block bana dia kind of vector bana dia 
h 
dense + sparse 
dense hi h ye 
ye ek intermediate layer h 




VIEWS in SQl


CREATE VIEW DetailsView AS
SELECT NAME, ADDRESS
FROM StudentDetails
WHERE S_ID < 5;


Multiple tables se 
CREATE VIEW MarksView AS
SELECT StudentDetails.NAME, StudentDetails.ADDRESS, StudentMarks.MARKS
FROM StudentDetails, StudentMarks
WHERE StudentDetails.NAME = StudentMarks.NAME;


Dropn
DROP VIEW view_name;


...............................................................
Deadlock in DBMS

deadlock occurs when two or more transactions are unable to the proceed because each transaction is waiting for the other to the release locks on resources.

#####  4 necessary conditions hoti h #####

No Pre-emption: Resources held by transactions cant be focefully taken.
Mutual Exclusion: Only one transaction can hold a particular resource at a time. 
Hold and wait: The Transactions holding resources may request additional resources held by others.
Circular wait:  A cycle of transactions exists where each transaction is waiting for the resource held by the next transaction in the cycle.


resouces ho sakte h locks...
ye hota h multi iser environment me

one of the way to prevent deadlock is to allot a time to transactions
ki itne time baad lock le hi liya jayega 
other is to acquire and release locks in the same order asap

brings the whole system to a Halt. 

Example â€“ let us understand the concept of deadlock suppose, Transaction T1 holds a lock on some rows in the Students table and needs to update some rows in the Grades table. Simultaneously, Transaction T2 holds locks on those very rows (Which T1 needs to update) in the Grades table but needs to update the rows in the Student table held by Transaction T1. 

 The deadlock avoidance method is suitable for smaller databases whereas the deadlock prevention method is suitable for larger databases. 
