................. Recursion ....................

1 - Reverse stack, so isme ye h ki top lo pop kro and then insertAtBottom function call kro
so recursion se stack reverse ho jayegi.

2 - Sort Stack, so isme h ki simply subproblems me todo ki ek ek element hatao and last se sort
chalu kro
and now usme sahi jagah insert kro element 

void insert(stack<int> &st, int x){
    if(st.size()==0 || st.top()<=x){
        st.push(x);
        return;
    }
    int a = st.top();
    st.pop();
    
    insert(st, x);
    st.push(a);
}
void sorting(stack<int> &st){
    if(st.size()==0){
        return;
    }
    
    int x = st.top();
    st.pop();
    
    sorting(st);
    insert(st, x);
}



......... TRIES.........
When to use Tries...

Tries helps in major 3 ways
1 - Find whether the given word ke liye exist krti h kya strings jinka prefix given word h
    ex: given word = "hel" and words in tries = help, hello , so it returns true

2 - Check whether exact same string exists or not 

3 - Insert string in trie.

Trie{
2 parameters hote h 
int arr[26]
bool flag 
}

root hoga ek (initially flag false hoga, array are empty)


class Node{
    Node* links[26];
    bool flag;
public:

    Node(){
        flag = false;
        for(int i = 0;i<26;i++){
            links[i] = NULL;
        }
    }
    bool containsKey(char ch) {
        return links[ch - 'a'] != NULL;
    }


    void put(char ch, Node* node) {
        links[ch - 'a'] = node;
    }

    Node* get(char ch) {
        return links[ch - 'a'];
    }

    void setEnd() {
        flag = true;
    }

    bool isEnd() {
        return flag;
    }
};
class Trie {
private:
    Node* root;
public:

    Trie() {
        root = new Node();
    }
    
    void insert(string word) {
        Node* node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node->containsKey(word[i])) {
                node->put(word[i], new Node());
            }
            node = node->get(word[i]);
        }
        node->setEnd();
    }
    
    bool search(string word) {
        Node* node = root;
        for (int i = 0; i < word.length(); i++) {
            if (!node->containsKey(word[i])) {
                return false;
            }
            node = node->get(word[i]);
        }
        return node->isEnd();
    }
    
    bool startsWith(string prefix) {
        Node* node = root;
        for (int i = 0; i < prefix.length(); i++) {
            if (!node->containsKey(prefix[i])) {
                return false;
            }
            node = node->get(prefix[i]);
        }
        return true;
    }
};


####################### TRIE 2 With count prefix and ends with ###############################

isme hmne flag ke jagah 2 int rakhe h 
count prsfix mtlb abhi tak iss node se start hone wale kitne h 
ends with mtlb iss node pe kon konse end ho rhe h

RULES :
1 - Insert me harr node pe count Prefix increase hoga but bass last ne endswith increase hoga
2 - Count Words equal to, so isme iterate kro and agr last wale ka endswith return krdo
3 - Count Words prefix wale, so isme last wale ka coutnPrefix krdo return 
4 - Erase me simply count resuce krte rho and last wale me endsWith bhi reduce krdo 


#include <bits/stdc++.h>
class Node{

private:
    int endsWith;
    int countPrefix;
    Node *links[26];

public:
    Node(){
        endsWith = 0;
        countPrefix = 0;
        for(int i = 0;i<26;i++){
            links[i] = NULL;
        }
    }

    void createNode(char ch, Node *newN){
        links[ch-'a'] = newN;
    }
    
    bool charExist(char ch){
        return links[ch-'a']!=NULL;
    }

    void increaseCP(){
        countPrefix++;
    }

    Node *getCharNode(char ch){
        return links[ch-'a'];
    }

    void increseEW(){
        endsWith++;
    }
    
    int getEndsWith(){
        return endsWith;
    }

    int getCountPrefix(){
        return countPrefix;
    }

    void reduceCountPrefix(){
        countPrefix--;
    }

    void reduceEndsWith(){
        endsWith--;
    }
};
class Trie {

Node* root;
public:
  Trie() {
    root = new Node();
  }

  void insert(string &word) {
    Node * node = root;
    for(int i = 0;i<word.size(); i++){
        if(!node->charExist(word[i])){
            node->createNode(word[i], new Node());
        }
        node = node->getCharNode(word[i]);
        node->increaseCP();
    }
    node->increseEW();
  }

  int countWordsEqualTo(string &word) {
    Node * node = root;
    for(int i = 0;i<word.size(); i++){
        if(!node->charExist(word[i])){
            return 0;
        }
        node = node->getCharNode(word[i]);
    }
    return node->getEndsWith();
  }

  int countWordsStartingWith(string &word) {
    Node * node = root;
    for(int i = 0;i<word.size(); i++){
        if(!node->charExist(word[i])){
            return 0;
        }
        node = node->getCharNode(word[i]);
    }
    return node->getCountPrefix();
  }

  void erase(string &word) {
    Node * node = root;
    for(int i = 0;i<word.size(); i++){
        if(node->charExist(word[i])){
            node = node->getCharNode(word[i]);
            node->reduceCountPrefix();
        }
    }
    node->reduceEndsWith();
  }
};


############## Ques 1 : Complete String ###############################

isme krna h ki ek string find krni h jiski saari substrings ho hamre pass array me 

so phle saari strings ko add kro apne trie me 
ab start kro iterate krna again , now agar meri iterate krte hue vo character ka node nhi h 
mtlb h ki vo phle nhi mila h to return krdo false
and agar uss node ka flag = false h mtlb yaha ki substring nhi mili h to bhi false krdo return 

to aise krke max length wala le lo... 



class Node{
public:
    Node *links[26];
    bool flag;

    Node(){
        flag = false;
        for(int i =0;i<26;i++){
            links[i] = NULL;
        }
    }

    bool charExists(char ch){
        return links[ch-'a']!=NULL;
    }

    void createNode(char ch, Node *node){
        links[ch-'a'] = node;
    }

    Node *getCharNode(char ch){
        return links[ch-'a'];
    }
};

class Trie{
    Node *root;

public:
    Trie(){
        root = new Node();
    }

    void insertInTrie(string word){
        Node *node = root;
        for(int i = 0;i<word.size(); i++){
            if(!node->charExists(word[i])){
                node->createNode(word[i], new Node());
            }
            node = node->getCharNode(word[i]);
        }
        node->flag = true;
    }

    bool isPresentPrefix(string word){
        Node *node  = root;
        for(int i = 0;i<word.size(); i++){
            if(!node->charExists(word[i])){
                return false;
            }
            node = node->getCharNode(word[i]);
            if(!node->flag){
                return false;
            }
        }
        return node->flag;
    }
};

string completeString(int n, vector<string> &a){
    // Write your code here.
    Trie *obj = new Trie();

    int len = 0;
    string ans = "";
    for(auto it:a){
        obj->insertInTrie(it);
    }

    for(auto it:a){
        int currLen = it.size();
        if(currLen>=ans.size()){
            bool isP = obj->isPresentPrefix(it);
            if(isP){
                if(ans==""){
                    ans = it;
                }
                else{
                    if(it.size()>ans.size()){
                        ans = it;
                    }
                    if(it.size() == ans.size() && it<ans){
                        ans = it;
                    }
                }
            }
        }
    }
    if(ans == "")return "None";
    return ans;
}


######################## Ques 2 ; Count distinct substrings ###########################

isme kya h ki agar hm set use krte to usme approx N*N*N ki sc jaati 
and N*N* log set size jaati 

so, isme 
int countDistinctSubstrings(string &s) {
    int i = 0;
    int N = s.size();
    Node *root = new Node();

    int ans =1;
    while(i<N){
        Node *node = root;
        int j = i;
        while(j<N){
            if(!node->hasChar(s[j])){
                ans +=1;
                node->createNode(s[j],new Node());
            }
            node = node->get(s[j]);
            j++;
        }
        i++;
    }
    return ans;
}




######################## Trie on BITS... #############################

isme kya h ki hm 2 lete h size links ka
0 and 1 
and 32 size starting from MSB start krte h 
and insert me jo bhi set h bit uss hisab se nodes banate h 
and ek h check ka ki xor krna h to uske dusri bit h to udhar jao 
and ans me | krte jao


class Node{
    Node *links[2];

public:
    Node(){
        links[0] = NULL;
        links[1] = NULL;
    }

    bool bitExist(int f){
        return (links[f]!=NULL);
    }

    void createNode(int f, Node* node){
        links[f] = node;
    }

    Node* get(int f){
        return links[f];
    }
};

class Trie{
    Node *root;

public:
    Trie(){
        root = new Node();
    }

    void insert(int num){
        Node *node = root;
        for(int i = 31;i>=0;i--){
            int bit = (num>>i) & 1;

            if(!node->bitExist(bit)){
                node->createNode(bit, new Node);
            }
            node = node->get(bit);
        }
    }

    int check(int num){
        int ans = 0;
        Node *node = root;
        for(int i = 31;i>=0;i--)
        {
            int bit = ((num>>i) & 1);
            if(node->bitExist(1-bit)){
                ans = ans | (1<<i);
                node = node->get(1-bit);
            }
            else{
                node = node->get(bit);
            }
        }
        return ans;
    }
    
};

class Solution {
public:
    int findMaximumXOR(vector<int>& nums) {
        int n = nums.size();
        Trie *obj = new Trie();
        for(int i = 0;i<n;i++){
            obj->insert(nums[i]);
        }
        int ans = 0;
        for(int i = 0;i<n;i++){
            ans = max(ans, obj->check(nums[i]));
        }

        return ans;
    }
};


next ques tha ki quesries h xi xor krna h maximise krne ke liye but ekements m se bade nhi hone chaoiye h 

to OFFLINE queries ka concept lagao
means ki phle aane wale limit se sort krdo and index bhi le lo 
phir existing trie me search krlo max XOR and agle baar insert krlo nexr limit se chote elemnts 



struct offlineQueries{
    int val;
    int limit;
    int idx;
    offlineQueries(int a, int b, int c){
        val = a;
        limit = b;
        idx = c;
    }
};

class Solution {
public:
    static bool comp(offlineQueries &q1, offlineQueries &q2){
        return q1.limit<q2.limit;
    }
    vector<int> maximizeXor(vector<int>& nums, vector<vector<int>>& queries) {
        sort(nums.begin(),nums.end());

        int q = queries.size();
        int n = nums.size();

        vector<offlineQueries> of;
        // Q
        for(int i = 0;i<q;i++){
            offlineQueries newOF = offlineQueries(queries[i][0], queries[i][1], i);
            of.push_back(newOF);
        }

        // QlogQ
        sort(of.begin(), of.end(), comp);

        Trie obj;
        vector<int> ans(q,0);
        int i = 0;
        int j = 0;
        // Q*32 + N*32 
        while(j<q){
            int limit = of[j].limit;
            int toXor = of[j].val;
            int idx = of[j].idx;
            while(i<n && nums[i]<=limit){
                obj.insert(nums[i]);
                i++;
            }
            if(i == 0){
                ans[idx] = -1;
            }
            else{
                ans[idx] = obj.check(toXor);
            }
            j++;
        }

        return ans;
    }
};
