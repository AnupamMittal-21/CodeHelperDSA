The major purpose of C++ programming is to introduce the concept of object orientation to the C programming language.

Smalltalk is considered as the first truly object-oriented programming language.

Object means a real word entity such as pen,
Any entity that has state and behavior is known as an object

An object's class acts as its blueprint


Inheritance
When one object acquires all the properties and behaviours of parent object i.e. known as inheritance. It provides code reusability. It is used to achieve runtime polymorphism.

Subclass or Derived Class
 "Base Class" or "Super Class" 
Reusability :existing class already contains some of the code we need, we can generate our new class from the old class thanks to inheritance. This allows us to utilize the fields and methods of the pre-existing class.


Polymorphism
When one task is performed by different ways : Different situations may cause an operation to behave differently


Abstraction
Hiding internal details and showing functionality is known as abstraction.
In C++ nd JAVA, we use abstract class and interface to achieve abstraction.


Encapsulation
Binding (or wrapping) code and data together into a single unit is known as encapsulation


Dynamic Binding - In dynamic binding, a decision is made at runtime regarding the code that will be run in response to a function call. For this, C++ supports virtual functions.

With the use of classes and objects, object-oriented programming makes code maintenance simple. Because inheritance allows for code reuse, the program is simpler because you don't have to write the same code repeatedly. Data hiding is also provided by ideas like encapsulation and abstraction


2 reason for Why is C++ a partial oop?

1 - The main function must always be outside the class in C++ and is required.
2) Global variables are a feature of the C++ programming language that can be accessed by any other object within the program and are defined outside of it. Encapsulation is broken here.

Class doesn't consume any space.
An object contains an address and takes up some space in memory.



Coupling refers to the knowledge or information or dependency of another class. 
You can use interfaces for the weaker coupling because there is no concrete implementation.

Cohesion refers to the level of a component which performs a single well-defined task
java.io package is a highly cohesive package because it has I/O related classes and interface. However, the java.util package is a weakly cohesive package because it has unrelated classes and interfaces.

Object-based programming language follows all the features of OOPs except Inheritance. JavaScript and VBScript are examples of object-based programming languages.



Difference Between Structure and Class in C++
 Members of a class are private by default.	
Members of a structure are public by default. 

Inheritance is possible with classes, and with structures

Acccess Modifiers 

Private: The access level of a private modifier is only within the class. It cannot be accessed from outside the class.

Default: The access level of a default modifier is only within the package. It cannot be accessed from outside the package. If you do not specify any access level, it will be the default.

Protected: The access level of a protected modifier is within the package and outside the package through child class. If you do not make the child class, it cannot be accessed from outside the package.

Public: The access level of a public modifier is everywhere. It can be accessed from within the class, outside the class, within the package and outside the package.

non-access modifiers, such as static, abstract, synchronized, native, volatile, transient, etc.




Role of Private Constructor
If you make any class constructor private, you cannot create the instance of that class from outside the class.

A class cannot be private or protected except nested class.

The protected access modifier can be applied on the data member, method and constructor. It can't be applied on the class.

class B extends A{  
  public static void main(String args[]){  
   B obj = new B();  
   obj.msg();  
  }  
}


If you are overriding any method, overridden method (i.e. declared in subclass) must not be more restrictive.

class A{  
protected void msg(){System.out.println("Hello java");}  
}  
  
public class Simple extends A{  
void msg(){System.out.println("Hello java");}//C.T.Error  
 public static void main(String args[]){  
   Simple obj=new Simple();  
   obj.msg();  
   }  
}  
The default modifier is more restrictive than protected. That is why, there is a compile-time error.

Friend

Java does not have the friend keyword like c++, which is used to access the non-public members

A friend class gets access to private and protected members of another class in which it is declared a friend. When granting access to a class, you need to specify that the access is granted to a class using the 'friend' keyword➡
friend class xclass

The friend declaration can go in a class's private, protected or public section. It does not matter where they appear.
friend function is declared outside a class but can access non-public members of the class, 

A friend function can be:

A global function : friend void friendFunction(base& obj);
A member function of another class : friend void anotherClass::memberFunction(base&);


Scope resolution operator in C++
1) To access a global variable when there is a local variable with same name:
int x; // Global x

int main()
{
int x = 10; // Local x
cout << "Value of global x is " << ::x;
cout << "\nValue of local x is " << x; 
return 0;
}

2) To define a function outside a class.
void A::fun() { cout << "fun() called"; }

3) To access a class’s static variables. 
Test::x = 1;

4) In case of multiple Inheritance: If the same variable name exists in two ancestor classes, we can use scope resolution operator to distinguish. 

class C: public A, public B
< A::x; A and B me dono me X h , and C inherits both A and B
< B::x;

5) Refer to a member of the base class in the derived object:
Derived obj;
    obj.Base::func();
    obj.func();


Constructor 

Constructors are mostly declared in the public section of the class though they can be declared in the private section of the class.
Constructors do not return values; hence they do not have a return type.
A constructor gets called automatically when we create the object of the class.

outside : student::student(){}

Default Constructor: No parameters. They are used to create an object with default values.

Parameterized Constructor: Takes parameters. Used to create an object with specific initial values.

Copy Constructor: Takes a reference to another object of the 
same class. Used to create a copy of an object.
ClassName (ClassName &obj)

Move Constructor: Takes an rvalue reference to another object. Transfers resources from a temporary object.


unlike the default constructor where the presence of any type of explicit constructor results in the deletion of the implicit default constructor, the implicit copy constructor will always be created by the compiler if there is no explicit copy constructor or explicit move constructor is present.


Shallow Copy: Shallow repetition is quicker. and isme same hi object ko point krte h new nhi create krte.
// Shallow Copy of Honda
    Car* copy_honda = &honda;

Deep Copy: isme exact copy banate h class ki 
// Deepcopy of Honda
    Car deepcopy_honda = honda;


Copy Constructor vs Assignment Operator in C++
It creates a separate memory block for the new object.
className(const className &obj) {
} 
vs 
Assignment Operato
It does not create a separate memory block or new memory space.
className obj1, obj2;
obj2 = obj1;

Virtual constructor 
The virtual mechanism works only when we have a base class pointer to a derived class object.

In C++, the constructor cannot be virtual, because when a constructor of a class is executed there is no virtual table in the memory, means no virtual pointer defined yet. So, the constructor should always be non-virtual.

But virtual destructor is possible.

#include<iostream>
using namespace std;
class b {
   public:
      b() {
         cout<<"Constructing base \n";
      }
      virtual ~b() {
         cout<<"Destructing base \n";
      }
};
class d: public b {
   public:
      d() {
         cout<<"Constructing derived \n";
      }
      ~d() {
         cout<<"Destructing derived \n";
      }
};
int main(void) {
   d *derived = new d();
   b *bptr = derived;
   delete bptr;
   return 0;
}
Output
Constructing base
Constructing derived
Destructing derived
Destructing base

agr virtual nhi lagaoge to derived ka destructor call nhi hoga


copy Constructor is used to creating an object copied from another. but if you want the program to decide at the runtime about the type of object created i.e. that object type is defined at runtime, not at compile-time and is based on some input provided by the user for a certain condition. in this situation, We need a copy constructor with some special powers to do this thing. So so to do this virtual copy constructor is declared that offers the cloning of objects in real-time.

Ye palle nhi pada code 
#include <iostream>
using namespace std;
class figure{
   public:
   figure() { }
   virtual
   ~figure() { }
   virtual void ChangeAttributes() = 0;
   static figure *Create(int id);
   virtual figure *Clone() = 0;
};
class square : public figure{
   public:
   square(){
      cout << "square created" << endl;
   }
   square(const square& rhs) { }
   ~square() { }
   void ChangeAttributes(){
      int a;
      cout<<"The side of square";
      cin>>a;
      cout<<"Area of square is "<<a*a;
   }
   figure *Clone(){
      return new square(*this);
   }
};
class circle : public figure{
   public:
   circle(){
      cout << "circle created" << endl;
   }
   circle(const circle& rhs) { }
   ~circle() { }
   void ChangeAttributes(){
      int r;
      cout << "enter the radius of the circle ";
      cin>>r;
      cout<<"the area of circle is "<<((3.14)*r*r);
   }
   figure *Clone(){
      return new circle(*this);
   }
};
class rectangle : public figure{
   public:
   rectangle(){
      cout << "rectangle created" << endl;
   }
   rectangle(const rectangle& rhs) { }
   ~rectangle() { }
   void ChangeAttributes(){
      int a ,b;
      cout<<"The dimensions of rectangle ";
      cin>>a>>b;
      cout<<"Area of rectangle is "<<a*b;
   }
   figure*Clone(){
      return new rectangle(*this);
   }
};
figure *figure::Create(int id){
   if( id == 1 ){
      return new square;
   }
   else if( id == 2 ){
      return new circle;
   }
   else{
      return new rectangle;
   }
}
class User{
   public:
   User() : figures(0){
      int input;
      cout << "Enter ID (1, 2 or 3): ";
      cin >> input;
      while( (input != 1) && (input != 2) && (input != 3) ){
         cout << "Enter ID (1, 2 or 3 only): ";
         cin >> input;
      }
      figures = figure::Create(input);
   }
   ~User(){
      if( figures ){
         delete figures;
         figures = 0;
      }
   }
   void Action(){
      figure *newfigure = figures->Clone();
      newfigure->ChangeAttributes();
      delete newfigure;
   }
   private:
   figure *figures;
};
int main(){
   User *user = new User();
   user->Action();
   delete user;
}
Enter ID (1, 2 or 3): 2
circle created
enter the radius of the circle R 3
the area of circle is 28.26


.................................................................


Destructor : 

Inside ya outside class kr sakte h scope resolution operator see 



It is not possible to define more than one destructor.
 tilde (~) symbol.
The destructor is only one way to destroy the object created by the constructor. Hence, destructor cannot be overloaded.
It cannot be declared static or const.
Destructor neither requires any argument nor returns any value.
It is automatically called when an object goes out of scope. 
Destructor release memory space occupied by the objects created by the constructor.
In destructor, objects are destroyed in the reverse of an object creation.

Objects are destroyed in the reverse order of their creation. In this case, t3 is the first to be destroyed, while t is the last.

object_name.~class_name() explicitly call krna destructor ko 

The default destructor works fine unless we have dynamically allocated memory or pointer in class. When a class contains a pointer to memory allocated in the class, we should write a destructor to release memory before the class instance is destroyed. This must be done to avoid memory leaks.

Yes, destructor can be defined as private when we want to control the deletion of the object manually

Private descturtor 
For dynamically created objects, it may happen that you pass a pointer to the object to a function and the function deletes the object. If the object is referred after the function call, the reference will become dangling. 
iss case ko handle krne ke liye hm control kr sakte h private 
destructor use krke

cases 

class Test {
private:
    ~Test() {}
}; 
It is not a compiler error to create private destructors.


int main() { Test t; }
fails in the compilation.
The compiler notices that the local variable ‘t’ cannot be destructed because the destructor is private. 

int main() { Test* t; }
no object being constructed, just creates a pointer of type “Test *”, so nothing is destructed.


 { Test* t = new Test; }
dynamic memory allocation, it is the programmer’s responsibility to delete 
where the destructor is declared private, an instance of the class can also be created using the malloc() function.

Test* t = (Test*)malloc(sizeof(Test)); ye bhi sahi h 

Test* t = new Test;
    delete t; ye nhi chalega kyuki delete ke liye public destrcutor chaiye h 


parent* p;
    p = new parent;
    // destructor called
    p->destruct();
chal jayega 



Deleting a derived class object using a pointer of base class type that has a non-virtual destructor results in undefined behavior. To correct this situation, the base class should be defined with a virtual destructor. 

vhi ki virtual nhi banaya base ka and base ptr delete kr rhe ho 
to derived ka delete nhi hoga 


A pure virtual destructor can be declared in C++.
for a pure virtual destructor, you must specify a destructor body.

The reason is that destructors (unlike other functions) are not actually ‘overridden’, rather they are always called in the reverse order of the class derivation. This means that a derived class destructor will be invoked first, then the base class destructor will be called.

class Base {
public:
    virtual ~Base() = 0; // Pure virtual destructor
};
Base::~Base() // Explicit destructor call
{
    std::cout << "Pure virtual destructor is called";
} sahi h 










