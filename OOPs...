The major purpose of C++ programming is to introduce the concept of object orientation to the C programming language.

Smalltalk is considered as the first truly object-oriented programming language.

Object means a real word entity such as pen,
Any entity that has state and behavior is known as an object

An object's class acts as its blueprint


Inheritance
When one object acquires all the properties and behaviours of parent object i.e. known as inheritance. It provides code reusability. It is used to achieve runtime polymorphism.

Subclass or Derived Class
 "Base Class" or "Super Class" 
Reusability :existing class already contains some of the code we need, we can generate our new class from the old class thanks to inheritance. This allows us to utilize the fields and methods of the pre-existing class.


Polymorphism
When one task is performed by different ways : Different situations may cause an operation to behave differently


Abstraction
Hiding internal details and showing functionality is known as abstraction.
In C++ nd JAVA, we use abstract class and interface to achieve abstraction.


Encapsulation
Binding (or wrapping) code and data together into a single unit is known as encapsulation


Dynamic Binding - In dynamic binding, a decision is made at runtime regarding the code that will be run in response to a function call. For this, C++ supports virtual functions.

With the use of classes and objects, object-oriented programming makes code maintenance simple. Because inheritance allows for code reuse, the program is simpler because you don't have to write the same code repeatedly. Data hiding is also provided by ideas like encapsulation and abstraction


2 reason for Why is C++ a partial oop?

1 - The main function must always be outside the class in C++ and is required.
2) Global variables are a feature of the C++ programming language that can be accessed by any other object within the program and are defined outside of it. Encapsulation is broken here.

Class doesn't consume any space.
An object contains an address and takes up some space in memory.



Coupling refers to the knowledge or information or dependency of another class. 
You can use interfaces for the weaker coupling because there is no concrete implementation.

Cohesion refers to the level of a component which performs a single well-defined task
java.io package is a highly cohesive package because it has I/O related classes and interface. However, the java.util package is a weakly cohesive package because it has unrelated classes and interfaces.

Object-based programming language follows all the features of OOPs except Inheritance. JavaScript and VBScript are examples of object-based programming languages.



Difference Between Structure and Class in C++
 Members of a class are private by default.	
Members of a structure are public by default. 

Inheritance is possible with classes, and with structures

Acccess Modifiers 

Private: The access level of a private modifier is only within the class. It cannot be accessed from outside the class.

Default: The access level of a default modifier is only within the package. It cannot be accessed from outside the package. If you do not specify any access level, it will be the default.

Protected: The access level of a protected modifier is within the package and outside the package through child class. If you do not make the child class, it cannot be accessed from outside the package.

Public: The access level of a public modifier is everywhere. It can be accessed from within the class, outside the class, within the package and outside the package.

non-access modifiers, such as static, abstract, synchronized, native, volatile, transient, etc.




Role of Private Constructor
If you make any class constructor private, you cannot create the instance of that class from outside the class.

A class cannot be private or protected except nested class.

The protected access modifier can be applied on the data member, method and constructor. It can't be applied on the class.

class B extends A{  
  public static void main(String args[]){  
   B obj = new B();  
   obj.msg();  
  }  
}


If you are overriding any method, overridden method (i.e. declared in subclass) must not be more restrictive.

class A{  
protected void msg(){System.out.println("Hello java");}  
}  
  
public class Simple extends A{  
void msg(){System.out.println("Hello java");}//C.T.Error  
 public static void main(String args[]){  
   Simple obj=new Simple();  
   obj.msg();  
   }  
}  
The default modifier is more restrictive than protected. That is why, there is a compile-time error.

Friend

Java does not have the friend keyword like c++, which is used to access the non-public members

A friend class gets access to private and protected members of another class in which it is declared a friend. When granting access to a class, you need to specify that the access is granted to a class using the 'friend' keyword➡
friend class xclass

The friend declaration can go in a class's private, protected or public section. It does not matter where they appear.
friend function is declared outside a class but can access non-public members of the class, 

A friend function can be:

A global function : friend void friendFunction(base& obj);
A member function of another class : friend void anotherClass::memberFunction(base&);


Scope resolution operator in C++
1) To access a global variable when there is a local variable with same name:
int x; // Global x

int main()
{
int x = 10; // Local x
cout << "Value of global x is " << ::x;
cout << "\nValue of local x is " << x; 
return 0;
}

2) To define a function outside a class.
void A::fun() { cout << "fun() called"; }

3) To access a class’s static variables. 
Test::x = 1;

4) In case of multiple Inheritance: If the same variable name exists in two ancestor classes, we can use scope resolution operator to distinguish. 

class C: public A, public B
< A::x; A and B me dono me X h , and C inherits both A and B
< B::x;

5) Refer to a member of the base class in the derived object:
Derived obj;
    obj.Base::func();
    obj.func();


Constructor 

Constructors are mostly declared in the public section of the class though they can be declared in the private section of the class.
Constructors do not return values; hence they do not have a return type.
A constructor gets called automatically when we create the object of the class.

outside : student::student(){}

Default Constructor: No parameters. They are used to create an object with default values.

Parameterized Constructor: Takes parameters. Used to create an object with specific initial values.

Copy Constructor: Takes a reference to another object of the 
same class. Used to create a copy of an object.
ClassName (ClassName &obj)

Move Constructor: Takes an rvalue reference to another object. Transfers resources from a temporary object.


unlike the default constructor where the presence of any type of explicit constructor results in the deletion of the implicit default constructor, the implicit copy constructor will always be created by the compiler if there is no explicit copy constructor or explicit move constructor is present.


Shallow Copy: Shallow repetition is quicker. and isme same hi object ko point krte h new nhi create krte.
// Shallow Copy of Honda
    Car* copy_honda = &honda;

Deep Copy: isme exact copy banate h class ki 
// Deepcopy of Honda
    Car deepcopy_honda = honda;


Copy Constructor vs Assignment Operator in C++
It creates a separate memory block for the new object.
className(const className &obj) {
} 
vs 
Assignment Operato
It does not create a separate memory block or new memory space.
className obj1, obj2;
obj2 = obj1;

Virtual constructor 
The virtual mechanism works only when we have a base class pointer to a derived class object.

In C++, the constructor cannot be virtual, because when a constructor of a class is executed there is no virtual table in the memory, means no virtual pointer defined yet. So, the constructor should always be non-virtual.

But virtual destructor is possible.

#include<iostream>
using namespace std;
class b {
   public:
      b() {
         cout<<"Constructing base \n";
      }
      virtual ~b() {
         cout<<"Destructing base \n";
      }
};
class d: public b {
   public:
      d() {
         cout<<"Constructing derived \n";
      }
      ~d() {
         cout<<"Destructing derived \n";
      }
};
int main(void) {
   d *derived = new d();
   b *bptr = derived;
   delete bptr;
   return 0;
}
Output
Constructing base
Constructing derived
Destructing derived
Destructing base

agr virtual nhi lagaoge to derived ka destructor call nhi hoga


copy Constructor is used to creating an object copied from another. but if you want the program to decide at the runtime about the type of object created i.e. that object type is defined at runtime, not at compile-time and is based on some input provided by the user for a certain condition. in this situation, We need a copy constructor with some special powers to do this thing. So so to do this virtual copy constructor is declared that offers the cloning of objects in real-time.

Ye palle nhi pada code 
#include <iostream>
using namespace std;
class figure{
   public:
   figure() { }
   virtual
   ~figure() { }
   virtual void ChangeAttributes() = 0;
   static figure *Create(int id);
   virtual figure *Clone() = 0;
};
class square : public figure{
   public:
   square(){
      cout << "square created" << endl;
   }
   square(const square& rhs) { }
   ~square() { }
   void ChangeAttributes(){
      int a;
      cout<<"The side of square";
      cin>>a;
      cout<<"Area of square is "<<a*a;
   }
   figure *Clone(){
      return new square(*this);
   }
};
class circle : public figure{
   public:
   circle(){
      cout << "circle created" << endl;
   }
   circle(const circle& rhs) { }
   ~circle() { }
   void ChangeAttributes(){
      int r;
      cout << "enter the radius of the circle ";
      cin>>r;
      cout<<"the area of circle is "<<((3.14)*r*r);
   }
   figure *Clone(){
      return new circle(*this);
   }
};
class rectangle : public figure{
   public:
   rectangle(){
      cout << "rectangle created" << endl;
   }
   rectangle(const rectangle& rhs) { }
   ~rectangle() { }
   void ChangeAttributes(){
      int a ,b;
      cout<<"The dimensions of rectangle ";
      cin>>a>>b;
      cout<<"Area of rectangle is "<<a*b;
   }
   figure*Clone(){
      return new rectangle(*this);
   }
};
figure *figure::Create(int id){
   if( id == 1 ){
      return new square;
   }
   else if( id == 2 ){
      return new circle;
   }
   else{
      return new rectangle;
   }
}
class User{
   public:
   User() : figures(0){
      int input;
      cout << "Enter ID (1, 2 or 3): ";
      cin >> input;
      while( (input != 1) && (input != 2) && (input != 3) ){
         cout << "Enter ID (1, 2 or 3 only): ";
         cin >> input;
      }
      figures = figure::Create(input);
   }
   ~User(){
      if( figures ){
         delete figures;
         figures = 0;
      }
   }
   void Action(){
      figure *newfigure = figures->Clone();
      newfigure->ChangeAttributes();
      delete newfigure;
   }
   private:
   figure *figures;
};
int main(){
   User *user = new User();
   user->Action();
   delete user;
}
Enter ID (1, 2 or 3): 2
circle created
enter the radius of the circle R 3
the area of circle is 28.26


.................................................................


Upcasting vs Downcasting in java

Upcasting:
ye implicitly and explicity dono ho jati h 

Parent p = new Child();
agar parent and child me same methods h to child call hoga means overriding ho rhi h 
agr parent and child me same data members h to parent ke changes hongi
age child ke alag wale method call krna chahunga to vo access nhi kr sakte na hi variables 
but parent ke sare variables and methods kr sakte h access 

Downcasting:
isme explicitly krna hoga 
Parent p = new Child();
Child c = (Child)p;
ye sahi h 
implicit nhi hoga means Child c = new Parent() nhi hoga , child object parent object ko reference nhi kr sakta
ab isme kya h ki hm 
child and parent ke common members and method h to child wale hi call honge
aur alg h parent me to vo bhi call ho jayenge and child me alag h to vo bhi call ho jayenge


.......................................................
Destructor : 

Inside ya outside class kr sakte h scope resolution operator see 



It is not possible to define more than one destructor.
 tilde (~) symbol.
The destructor is only one way to destroy the object created by the constructor. Hence, destructor cannot be overloaded.
It cannot be declared static or const.
Destructor neither requires any argument nor returns any value.
It is automatically called when an object goes out of scope. 
Destructor release memory space occupied by the objects created by the constructor.
In destructor, objects are destroyed in the reverse of an object creation.

Objects are destroyed in the reverse order of their creation. In this case, t3 is the first to be destroyed, while t is the last.

object_name.~class_name() explicitly call krna destructor ko 

The default destructor works fine unless we have dynamically allocated memory or pointer in class. When a class contains a pointer to memory allocated in the class, we should write a destructor to release memory before the class instance is destroyed. This must be done to avoid memory leaks.

Yes, destructor can be defined as private when we want to control the deletion of the object manually

Private descturtor 
For dynamically created objects, it may happen that you pass a pointer to the object to a function and the function deletes the object. If the object is referred after the function call, the reference will become dangling. 
iss case ko handle krne ke liye hm control kr sakte h private 
destructor use krke

cases 

class Test {
private:
    ~Test() {}
}; 
It is not a compiler error to create private destructors.


int main() { Test t; }
fails in the compilation.
The compiler notices that the local variable ‘t’ cannot be destructed because the destructor is private. 

int main() { Test* t; }
no object being constructed, just creates a pointer of type “Test *”, so nothing is destructed.


 { Test* t = new Test; }
dynamic memory allocation, it is the programmer’s responsibility to delete 
where the destructor is declared private, an instance of the class can also be created using the malloc() function.

Test* t = (Test*)malloc(sizeof(Test)); ye bhi sahi h 

Test* t = new Test;
    delete t; ye nhi chalega kyuki delete ke liye public destrcutor chaiye h 


parent* p;
    p = new parent;
    // destructor called
    p->destruct();
chal jayega 



Deleting a derived class object using a pointer of base class type that has a non-virtual destructor results in undefined behavior. To correct this situation, the base class should be defined with a virtual destructor. 

vhi ki virtual nhi banaya base ka and base ptr delete kr rhe ho 
to derived ka delete nhi hoga 


A pure virtual destructor can be declared in C++.
for a pure virtual destructor, you must specify a destructor body.

The reason is that destructors (unlike other functions) are not actually ‘overridden’, rather they are always called in the reverse order of the class derivation. This means that a derived class destructor will be invoked first, then the base class destructor will be called.

class Base {
public:
    virtual ~Base() = 0; // Pure virtual destructor
};
Base::~Base() // Explicit destructor call
{
    std::cout << "Pure virtual destructor is called";
} sahi h 



Inheritance represents the IS-A relationship which is also known as a parent-child relationship.

Java : class Programmer extends Employee
Cpp = class A : public B{}

there can be three types of inheritance in java: 
single, multilevel and hierarchical.

When one class inherits multiple classes, it is known as multiple inheritance.
and multiple inheritence is not supported in java using class

coz...To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Consider a scenario where A, B, and C are three classes. The C class inherits A and B classes. If A and B classes have the same method and you call it from child class object, there will be ambiguity to call the method of A or B class.

The sealed modifier is used to prevent derivation from a class. 
mtlb inheritance hone se rokna. An error occurs if a sealed class is specified as the base class of another class


The diamond problem
For instance, let us assume that Java does support multiple inheritance. With that assumption consider the following example


public class abstract Sample {
   public abstract demo();
}


ye next level 
public class Super1 extends Sample{
   public void demo() {
      System.out.println("demo method of super1");
   }
}
public class Super2 extends Sample{
   public void demo() {
      System.out.println("demo method of super2");
   }
}

next level 
public class SubClass extends Super1, Super2 {
   public static void main(String args[]) {
      SubClass obj = new SubClass();
      obj.demo();
   }
}

now compiler demo ki do copies banayega and jab call krenge to nhi pta hoga usse ki konsa call krna h 
so error aa jayegi, isiliye runtime na aaye to vo allow hi nhi krta as compile error is better than run time error 


solution 
public class InterfaceExample implements MyInterface1, MyInterface2{
interfaces banao usse kr sakte h multiple inheritence



What is object slicing?
"Slicing" is where you assign an object of a derived class to an instance of a base class, thereby losing part of the information - some of it is "sliced" away.

class A {
   int foo;
};

class B : public A {
   int bar;
};
So an object of type B has two data members, foo and bar.

Then if you were to write this:

B b;

A a = b;
Then the information in b about member bar is lost in a




Does overloading work with Inheritance?

class Base
{
    public int f(int i)
    {
        System.out.print("f (int): ");
        return i+3;
    }
}
class Derived extends Base
{
    public double f(double i)
    {
        System.out.print("f (double) : ");
        return i + 3.3;
    }
}
class myprogram3
{
    public static void main(String args[])
    {
        Derived obj = new Derived();
        System.out.println(obj.f(3));
        System.out.println(obj.f(3.3));
    }
}
C++ me agar ye case h to keval derived ka hi call hoga 
but java me based on input function overloading ho jayegi across classes 





Association
Association is a relationship between two objects. In other words, association defines the multiplicity between objects. 
one-to-one, one-to-many, many-to-one, many-to-many 
Aggregation is a special form of association. Composition is a special form of aggregation.

Aggregation
When an object ‘has-a’ another object, then you have got an aggregation between them


Composition
Composition is a special case of aggregation. In a more specific manner, a restricted aggregation is called composition. When an object contains the other object, if the contained object cannot exist without the existence of container object, then it is called composition.



Generalization
Converting a subclass type into a superclass type is called ‘Generalization‘ because we are making the subclass to become more general and its scope is widening. This is also called widening or up casting. Widening is safe because the classes will become more general.
Java compiler will not ask for cast operator in generalization

Father father;
  
 // new operator returns a subclass reference
 father = (Father) new Son();
but iss se ab child wale nhi kr sakte call 
we can access all the superclass methods, but not the subclass methods.




Specialization
Converting a super class type into a sub class type is called ‘Specialization‘. Here, we are coming down from more general form to a specific form and hence the scope is narrowed. Hence, this is called narrowing or down-casting.

Narrowing is not safe because the classes will become more and more specific thus giving rise to more and more doubts.
Java compiler specifically asks for the casting. This is called explicit casting.

try {
            // son is a sub class reference
            Son son;
  
            // new operator returns a superclass reference
            // which is narrowed using casting
            // and stored in son variable
  
            // This will throw exception
            son = (Son) new Father();
  
            // Through a narrowed reference of the superclass
            // we can neither access superclass method
            // and nor the subclass methods
  
            // Below lines will show
            // an error when uncommented
            // son.work();
            // son.play();
        }
        catch (Exception e) {

but 
// son is a subclass reference
        Father father;
  
        // new operator returns a subclass reference
        // which is stored in the father variable
        // father stores a Father class reference
        // because of implicit casting
        father = new Son();
  
        // father is narrowed
        Son son = (Son)father;
  
        son.work(); // works well
        son.play(); // works well




Polymorphism in Java
an overridden method is called through the reference variable of a superclass. The determination of the method to be called is based on the object being referred to by the reference variable.

Upcasting
If the reference variable of Parent class refers to the object of Child class, it is known as upcasting.


class Bike{  
  void run(){System.out.println("running");}  
}  
class Splendor extends Bike{  
  void run(){System.out.println("running safely with 60km");}  
  
  public static void main(String args[]){  
    Bike b = new Splendor();//upcasting  
    b.run();  
  }  
}  
Test it Now
Output:

running safely with 60km.



static binding
When type of the object is determined at compiled time(by the compiler), it is known as static binding.

If there is any private, final or static method in a class, there is static binding.


Dynamic binding
When type of the object is determined at run-time, it is known as dynamic binding. done by JVM not compiler 




Advantage of Encapsulation in Java
ye kaam hota h access modifiers ki help se 

By providing only a setter or getter method, you can make the class read-only or write-only. In other words, you can skip the getter or setter methods.

It provides you the control over the data. Suppose you want to set the value of id which should be greater than 100 only, you can write the logic inside the setter method. You can write the logic not to store the negative numbers in the setter methods.

It is a way to achieve data hiding in Java because other class will not be able to access the data through the private data members.

The encapsulate class is easy to test. So, it is better for unit testing.

The standard IDE's are providing the facility to generate the getters and setters. So, it is easy and fast to create an encapsulated class in Java.





Abstraction
Using Abstract Class
Using Interface

Abstract classes are the same as normal Java classes the difference is only that an abstract class uses abstract keyword while the normal Java class does not use.

An abstract class contains abstract methods as well as concrete methods If we want to use an abstract class, we have to inherit it from the base class.

If the class does not have the implementation of all the methods of the interface, we should declare the class as abstract. It provides complete abstraction. It means that fields are public static and final by default and methods are empty.

abstract class Demo  
{  
//abstract method  
abstract void display();  
} 



an interface contains empty methods (methods that do not have method implementation) and variables.
 it is a collection of abstract methods (the method that does not have a method body) and static constants. 
each method is public and abstract and does not contain any constructor.
also helps to achieve multiple inheritance. 


Abstraction is a concept, which is allowed by encapsulation.


......................................................................


Questions at the end.....

....................................................................

read://https_www.edureka.co/?url=https%3A%2F%2Fwww.edureka.co%2Fblog%2Fdifference-between-c-c-and-java

All predefined types are objects
All operations performed on objects must be only through methods exposed at the objects.
ye nhi hota java me issi liye vo pure OOPs nhi h 

Wrapper Class: Wrapper class provides the mechanism to convert primitive into object and object into primitive

An array in Java is an object. 
we can create arrays by using new operator and we know that every object is created using new operator


n languages like Java or C#, you can create instances of concrete classes that inherit from an abstract class and provide implementations for the abstract methods. These concrete classes can then be instantiated and used to create objects.

In summary, while you cannot create an instance of an abstract class, you can create instances of concrete classes that inherit from the abstract class and provide implementations for its abstract methods.




Java garbage collection is the process by which Java programs perform automatic memory management. Java programs compile to bytecode that can be run on a Java Virtual Machine, or JVM for short. When Java programs run on the JVM, objects are created on the heap, which is a portion of memory dedicated to the program. Eventually, some objects will no longer be needed. The garbage collector finds these unused objects and deletes them to free up memory.



In the first step, unreferenced objects are identified and marked as ready for garbage collection. In the second step, marked objects are deleted. Optionally, memory can be compacted after the garbage collector deletes objects, so remaining objects are in a contiguous block at the start of the heap. The compaction process makes it easier to allocate memory to new objects sequentially after the JVM allocates the memory blocks to existing objects.



Java finally block is a block used to execute important code such as closing the connection, etc.

Java finally block is always executed whether an exception is handled or not. Therefore, it contains all the necessary statements that need to be printed regardless of the exception occurs or not.

The finally block follows the try-catch block.
ye to call hoga hi hoga 

Rule: For each try block there can be zero or more catch blocks, but only one finally block.
Note: The finally block will not be executed if the program exits (either by calling System.exit() or by causing a fatal error that causes the process to abort).





FInal :
 
Final variables
If a variable is declared with the final keyword, its value cannot be changed once initialized. Note that the variable does not necessarily have to be initialized at the time of declaration. If it’s declared but not yet initialized, it’s called a blank final variable.

Final parameters
If you ever see the final keyword with a parameter variable, it means that the value of this variable cannot be changed anywhere in the function.

Final methods
A method, declared with the final keyword, cannot​ be overridden or hidden by subclasses.


Final classes
A class​ declared as a final class, cannot be subclassed


When an error occurs within a method, the method creates an object and hands it off to the runtime system. The object, called an exception object, contains information about the error, including its type and the state of the program when the error occurred. Creating an exception object and handing it to the runtime system is called throwing an exception.


The search begins with the method in which the error occurred and proceeds through the call stack in the reverse order that the methods were called. When an appropriate handler is found, the run-time system passes the exception to the handler. An exception handler is considered appropriate if the type of the exception object thrown matches the type that can be handled by the handler. The exception handler chosen is said to catch the exception. If the runtime system exhaustively searches all the methods on the call stack without finding an appropriate exception handler, as shown in the next figure, the runtime system (and, consequently, the program) terminates.




Exceptions are typically caused by conditions that occur at runtime, such as division by zero, accessing an invalid memory address, or attempting to open a file that does not exist. When an exception is thrown, the program can catch and handle the exception to prevent it from crashing.

In summary, errors are generally mistakes in the code that prevent it from running correctly, while exceptions are unexpected events that occur during program execution and can be caught and handled to prevent program crashes. Exceptions are used to handle runtime errors gracefully and improve the robustness of a program.

throwable ke andr exceptions and error 
exception me checked jo ccompile dekh sake and unchechked jo runt ime pe pata chale 

error to virtual machine erroe and assertion error 
catch (ArithmeticException e) { catch (Exception e) { iss order me rakhna chaiye h specific to general 





 Exception propagation using throws keyword

We have declared the IOException using throws keyword and using the throw keyword to raise the exception in the myMethod().

void myMethod()throws IOException{
    //throw exception using throw keyword
    throw new IOException("IO Exception occurred");
  }

The ideal way to use throws is by declaring the exceptions in method signature and handle the exceptions using try-catch in calling method.

mtlb basically throw and throws use krlo ya try catch 
throw kro to bata do ki ye method trhrows error and calling me try catch laga ke handle krlo 



Finalize() is the method of Object class. This method is called just before an object is garbage collected. finalize() method overrides to dispose system resources, perform clean-up activities and minimize memory leaks.


Ternary Operator
condition ? value_if_true : value_if_false

Enumeration (or enum) in C
Enumeration (or enum) is a user defined data type in C. It is mainly used to assign names to integral constants, the names make a program easy to read and maintain.


enum week{Mon, Tue, Wed};
enum week day;

// Or

enum week{Mon, Tue, Wed}day;

enum week{Mon, Tue, Wed, Thur, Fri, Sat, Sun};
 
int main()
{
    enum week day;
    day = Wed;
    printf("%d",day);
    return 0;
}2

enum year{Jan, Feb, Mar, Apr, May, Jun, Jul,
          Aug, Sep, Oct, Nov, Dec};
 
int main()
{
   int i;
   for (i=Jan; i<=Dec; i++)     
      printf("%d ", i);
       
   return 0;
}0 1 2 3 4 5 6 7 8 9 10 11



Interesting facts about initialization of enum. 
1. Two enum names can have same value. For example, in the following C program both ‘Failed’ and ‘Freezed’ have same value 0. 
and automatically 0 se start krta h, if not mentioned 

3. We can assign values to some name in any order. All unassigned names get value as value of previous name plus one. 

enum state  {working, failed};
enum result {failed, passed};
 
int main()  { return 0; }
Output: 

Compile Error: 'failed' has a previous declaration as 'state failed'





Cohesion refers to what the class (or module) can do. Low cohesion would mean that the class does a great variety of actions - it is broad, unfocused on what it should do. High cohesion means that the class is focused on what it should be doing, i.e. only methods relating to the intention of the class.

As for coupling, it refers to how related or dependent two classes/modules are toward each other. For low coupled classes, changing something major in one class should not affect the other. High coupling would make it difficult to change and maintain your code; since classes are closely knit together, making a change could require an entire system revamp.



structs can have methods.
structs cannot be inherited


Vtable and Vptr in cpp...



Memory Leak in CPP
When promgrammer uses new( or malloc/calloc) means dynamic allocation hota h memory ka and usse deallocate nhi krte 
like delete operator or free()

NO automatic Garbage collction in cpp , isiliye programmer ki responsiblity hoti h ki vo usse free kre 

n C++, there is no automatic garbage collection. It means that any memory that is dynamically allocated by the programmer needs to be freed after its usage manually by the programmer. If the programmer forgets to free this memory, it will occupy the space from till the program lives and will be unavailable to other processes. This is called memory leak.

Factors 
Neglected Deallocation: Forgetting to release memory allocated with new or malloc.

Lost Pointers: Losing the reference to dynamically allocated memory, making it impossible to deallocate it.
ye to khatarnak h ki tumpe reference hi nhi  h

Exception Handling: Failing to deallocate memory in the event of an exception. ha isiliye finally hota h java me 

Complex Data Structures: Improper handling of memory in complex data structures like linked lists, trees, and graphs.

int* ptr = new int(5); ye dynamic h ab isse free nhi kra to memory leak kehlayegi vo 

DELETE and DELETE[]
The delete operator should be used to free a single allocated memory space, whereas the delete [] operator should be used to free an array of data values.

Memory leaks can be detected using tools like Valgrind, AddressSanitizer, and Dr. Memory, as well as through manual code review.


best practices to avoid memory leak in C++:

Instead of managing memory manually, try to use smart pointers where applicable.
Use std::string instead of char *. The std::string class handles all memory management internally, and it’s fast and well-optimized.
Never use a raw pointer unless it’s to interface with an older lib.
Have as few new/delete calls at the program level as possible – ideally NONE. Anything that requires dynamic memory should be buried inside an RAII object that releases the memory when it goes out of scope. RAII allocate memory in constructor and release it in destructor, so that memory is guaranteed to be deallocated when the variable leave the current scope.
Memory allocated by new keyword should be deallocated by delete keyword.
Memory allocated by malloc, calloc, realloc should be deallocated by free.



Smart Pointers | Dangling Pointers | Void Pointers 

Dangling pointer: A pointer pointing to a memory location that has been deleted (or freed) is called a dangling pointer. There are three different ways where Pointer acts as a dangling pointer:
By deallocating memory
Function Call
When the variable goes out of scope

points to deleted object 
occurs during object destruction time  (free())


Void pOinter: 
void * 
ye ek type h pointer ka that doesnot have any specific type..
to ye kisi ko bhi point kr sakta h 
char ko krana chaha to char ko, int ko , ya kisi ko bhi

void pointers cannot be dereferenced. However, it can be done using typecasting the void pointer
Pointer arithmetic is not possible on pointers of void due to lack of concrete value and size.
its a kind of general purpose pointer 


############ C me deallocate memory.. ########

void *realloc(void *ptr, size_t size);

If “size” is zero, then call to realloc is equivalent to “free(ptr)”. And if “ptr” is NULL and size is non-zero then call to realloc is equivalent to “malloc(size)”. 

int *ptr = (int*)malloc(10); // isme 10 bytes ki memory lost hogi

int *ptr = (int*) malloc(10);
 
/* we are calling realloc with size = 0 */
realloc(ptr, 0);
kyuki size = 0 h to ye ek tarah se free(ptr) ke tarah kaam krega
ab isme nhi hogi memory leak 

stdlib.h me hote h ye malloc, calloc, realloc, free function

############### Function call stack in C ########### 
we have  stack, stack pointer, stack frame with us...



############## Runtime Errors in CPP ##########

sucessfully compile hone ke baad runtime pe hota h ye errors 

types of Runtime Errors: 

1 - SIGFPE: SIGFPE is a floating-point error. It is virtually always caused by a division by 0. 
Division by Zero.
Modulo Operation by Zero.
Integer Overflow.

2 - SIGABRT: It is an error itself is detected by the program then this signal is generated using call to abort() function. This signal is also used by standard library to report an internal error. assert() function in C++ also uses abort() to generate this signal. Below is the program to illustrate the SIGBRT error:

excessive memory dene ka try krna 
int a = 100000000000;
int* arr = new int[a];

3 - NZEC: This error denotes “Non-Zero Exit Code”. 
For C users, agr main() method return 0 na kre
Java/C++ me exception case me hota h, jese ki 

-Infinite Recursion or if you run out of stack memory.
-Negative array index is accessed.
-ArrayIndexOutOfBounds Exception.
-StringIndexOutOfBounds Exception.

4 - SIGSEGV: “Segmentation Fault“.
jab program tries to access a memory that is not allowed to access jese ki

-Accessing an array out of bounds.
-Dereferencing NULL pointers.
-Dereferencing freed memory.
-Dereferencing uninitialized pointers.
-Incorrect use of the “&” (address of) and “*”(dereferencing) operators.
-Improper formatting specifiers in printf and scanf statements.
-Stack overflow.
-Writing to read-only memory.


########### EXE files ########### 
EXE files are portable, user friendly and efficient execution 
also ther run in closed environment hence isolated 

EXE file contains binary code carrying instruction for computer CPU 
############### Executing C/C++ code ########
direct main function hi nhi hota h entry point
other function call hote h phle 
which setups arguments , prepare environment variable for program execution etc 
EXE (executible file )


############# String Stream in C ############
vector<string> split(const string &s, char delimiter) {
    vector<string> tokens;
    string token;
    istringstream tokenStream(s);
    while (getline(tokenStream, token, delimiter)) {
        tokens.push_back(token);
    }
    return tokens;
}

// Function to convert IPv4 to IPv6-like format
string ipv4ToIpv6(const string& ipv4) {
    // Split the IPv4 address on '.'
    vector<string> octets = split(ipv4, '.');
    
    if (octets.size() != 4) {
        return "Invalid IPv4 address";
    }
    
    stringstream ipv6;
    ipv6 << "::FFFF:";
    // Convert each octet to hexadecimal and merge them in pairs
    for (int i = 0; i < 4; i += 2) {
        int firstOctet = stoi(octets[i]);     // Convert first octet of the pair to integer
        int secondOctet = stoi(octets[i + 1]); // Convert second octet of the pair to integer
        // Combine them into a 4-digit hexadecimal number
        ipv6 << hex << setw(2) << setfill('0') << firstOctet
             << setw(2) << setfill('0') << secondOctet;
        
        // Add ':' separator between every pair except the last one
        if (i < 2) {
            ipv6 << ":";
        }
    }
    
    return ipv6.str();
}



######### Compiling a C Program ######### 
Compilation means csource code to machine code 

compilation in terminal : gcc filename.c –o filename
run: ./filename

to save temp files: -Wall -save-temps filename.c –o filename  


1. Pre-processing
This is the first phase through which source code is passed. This phase includes:

Removal of Comments
Expansion of Macros
Expansion of the included files.
Conditional compilation
The preprocessed output is stored in the filename.i. Let’s see what’s inside filename.i: using $vi filename.i 

In the above output, the source file is filled with lots and lots of info, but in the end, our code is preserved. 

printf contains now a + b rather than add(a, b) that’s because macros have expanded.
Comments are stripped off.
#include<stdio.h> is missing instead we see lots of code. So header files have been expanded and included in our source file.

Assembly code : isme hote h english me code but expanded and not much readable

O file me @^C ye sab likha hota h bhut sara and  beech me .comment, .note.GNU-Stack aisa kuch 

2. Compiling
The next step is to compile filename.i and produce an; intermediate compiled output file filename.s. This file is in assembly-level instructions. Let’s see through this file using $nano filename.s  terminal command.

3. Assembling
In this phase the filename.s is taken as input and turned into filename.o by the assembler. This file contains machine-level instructions. At this phase, only existing code is converted into machine language, and the function calls like printf() are not resolved. Let’s view this file using $vi filename.o 

4. Linking
This is the final phase in which all the linking of function calls with their definitions is done. Linker knows where all these functions are implemented. Linker does some extra work also, it adds some extra code to our program which is required when the program starts and ends. For example, there is a code that is required for setting up the environment like passing command line arguments. This task can be easily verified by using $size filename.o and $size filename. Through these commands, we know how the output file increases from an object file to an executable file. This is because of the extra code that Linker adds to our program. 


Suppose, you save a C program with prg1.c – here .c is the extension of C code, prg1.c file contains the program (source code of a C program). Preprocessor reads the file and generates the prg1.i (prg1.ii – for c++ source code) file, this file contains the preprocessed code.
Compiler reads the prg1.i file and further converts into assembly code and generates prg1.s and then finally generates object code in prg1.o file.
Linker reads prg1.o file and links the other assembly/object code or library files and generates executable file named prg1.exe.
Loader loads the prg1.exe file into the main/primary memory and finally program run.
One more file is created that contains the source code named prg1.bak; it’s a backup file of the program files.



################## Running Code in PYTHON ############

Compilation
The program is converted into byte code. Byte code is a fixed set of instructions that represent arithmetic, comparison, memory operations, etc. It can run on any operating system and hardware. The byte code instructions are created in the .pyc file. The .pyc file is not explicitly created as Python handles it internally but it can be viewed with the following command:



-m and py_compile represent module and module name respectively. This module is responsible to generate .pyc file. The compiler creates a directory named  __pycache__ where it stores the first.cpython-38.pyc file. 

Interpreter
The next step involves converting the byte code (.pyc file) into machine code. This step is necessary as the computer can understand only machine code (binary code). Python Virtual Machine (PVM) first understands the operating system and processor in the computer and then converts it into machine code. Further, these machine code instructions are executed by processor and the results are displayed.


Execution of Python Program

However, the interpreter inside the PVM translates the program line by line thereby consuming a lot of time. To overcome this, a compiler known as Just In Time (JIT) is added to PVM. JIT compiler improves the execution speed of the Python program. This compiler is not used in all Python environments like CPython which is standard Python software.

To execute the first.cpython-38.pyc we can use the following command:



To view the byte code of the file – first.py we can type the following command as :



The dis command is known as “disassembler” that displays the byte code in an understandable format. The code represents 5 columns:

Line Number
offset position of byte code
name of byte code instruction
instruction’s argument
constants or names (in brackets)
