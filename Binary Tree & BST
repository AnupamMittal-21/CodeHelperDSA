######################### Basics of trees ####################################################

Full Binary Tree: Either 0 or 2 childrens
Complete BT: All levels are completely filled, except last one, if it is not completely filled,
            then it must have all the nodes in as left as possible.
Perfect BT: All leaf node should be at same level, Each level has 0 or pow(2, level-1)
Balanced BT: Height of tree at max Log(N)
Degenerate Tree: Linear tree similar to Linked List.


######################### Traversal - Preorder | Postorder | Inorder - DFS ####################


######################### Traversal - Level Order - BFS #######################################
TC: O(N)
SC: O(N)

Make sure to keep an queue in case of BFS, and if we want to create a 2D array, then add for loop
  int size = q.size();
  while(size--){
    //Logic  
  }

vector<vector<int>> levelOrder(TreeNode* root) {
    if(root==NULL)return {};
    queue<TreeNode *> q;
    q.push(root);
    // bool flag = true; // In case of zig zag. 
    vector<vector<int>> two_ans;
    while(!q.empty()){
        int size = q.size();
        vector<int> ans;
        for(int i = 0;i<size;i++){
          TreeNode *curr = q.front();
          q.pop();

          // int index = (flag)?i:(size-i-1); // In case of zig zag. 
          // ans[index] = curr->val  // In case of zig zag. 

          ans.push_back(curr->val);
          if(curr->left!=NULL)
              q.push(curr->left);
          if(curr->right!=NULL)
              q.push(curr->right);
        }
        two_ans.push_back(ans);
    }
    return two_ans;
}

// In case of zig zag. 
######################### Iterative Preorder (Root, Left, Right) ##############################
TC: O(N)
SC: O(N)
Intuition: 
  Take a stack, take out element at top, push Right then Left.
  Because we want to go to extreme left every time, so we push right first then left, 
  so that left is pushed at last and it will be taken first as Stack is LIFO.

vector<int> preorderTraversal(TreeNode* root) {
    if(root==NULL)return {};
    stack<TreeNode *> st;
    st.push(root);

    vector<int> ans;
    while(!st.empty()){
        TreeNode *curr = st.top();
        st.pop();
        ans.push_back(curr->val);
        if(curr->right!=NULL){
            st.push(curr->right);
        }
        if(curr->left!=NULL){
            st.push(curr->left);
        }
    }
    return ans;
}

######################### Iterative Inorder (Root, Left, Right) ##############################
intuition: 
  Take a stack, go to the extreme left, now start popping elements
  take out the element at top, go Right then push till extreme Left.
  Because we want to go to the extreme left every time, then print the node, 
  so we push all the left then the current node and then the right

SC = O(N) in the case of a skewed tree.
else normally or in the best case it is O(logN)

vector<int> inorderTraversal(TreeNode* root) {
    if(root==NULL)return {};
    stack<TreeNode*> st;
    vector<int> ans;
    while(root){
        st.push(root);
        root = root->left;
    }

    while(st.size()){
        TreeNode *curr = st.top();
        st.pop();
        ans.push_back(curr->val);

        if(curr->right){
            curr = curr->right;
            while(curr){
                st.push(curr);
                curr = curr->left;
            }
        }
    }
    return ans;
}


######################### Iterative Postorder (Left, Right, Root) ##############################
intuition: 
  Take two stacks, one for storing the answer, and other one is similar to auxiliary stack,
  think it is as we print root, now since stack works in opposite of push and we want top pe right ho
  so we push left, then Right
  take out element at top, print it, go left and then go right

vector<int> postorderTraversal(TreeNode* root) {
    if(root==NULL)return {};
    vector<int> ans;
    stack<TreeNode *> st;
    st.push(root);

    while(!st.empty()){
        TreeNode *curr = st.top();
        st.pop();
        ans.push_back(curr->val);
        if(curr->left){
            st.push(curr->left);
        }
        if(curr->right){
            st.push(curr->right);
        }
    }
    reverse(ans.begin(), ans.end());
    return ans;
}


With 1 stack TC: O(2*N)
Very Hard, mujhse nhi aaya ye samajh me...



######################### Iterative Post | Post | In | All in one ##############################
TC: O(3N)
SC: O(4N)
intuition: 
  Take pair in stack, one is node, other is num, num can be 1, 2 , 3
  if num == 1
    preorder
    num++
    go to left
  if num == 2
    inorder
    num++
    right
  if num == 3
    postorder

CODE: 
vector<vector<int>> preInPostTraversal(Node* root) {

    vector<int> pre, in, post;

    if (root == NULL) {
        return {};
    }
    stack<pair<Node*, int>> st;

    st.push({root, 1});

    while (!st.empty()) {
        auto it = st.top();
        st.pop();
        if (it.second == 1) {
            pre.push_back(it.first->data);
            it.second = 2;
            st.push(it); 
            if (it.first->left != NULL) {
                st.push({it.first->left, 1});
            }
        }
        else if (it.second == 2) {
            in.push_back(it.first->data);
            it.second = 3;
            st.push(it); 
            if (it.first->right != NULL) {
                st.push({it.first->right, 1});
            }
        }
        else {
            post.push_back(it.first->data);
        }
    }
}

Traversal done.

################################# Part - 2 ###############################################


####################### Height of BT ######################################################
Recursion: O(log N), Iterative: O(N) 
Simple one liner 
 
int maxDepth(TreeNode* root) {
    if(root==NULL)return 0;
    return max(maxDepth(root->left) , maxDepth(root->right)) +1 ;
}

Diameter question just add 2 lines 
ans = max(ans, l + r + 1);
return max(l, r) + 1;


####################### Tree Balanced or not ######################################################
difference of height <=1
Naive appraoch is to do a dfs and call height function at each node and checking the condition
O(N*N)

Note: Return -1 in case of unbalance, and check it any is -1 then keep on returning -1.

int height(TreeNode *root){
    if(root==NULL)return 0;
    int left_h = height(root->left);
    int right_h = height(root->right);
    if(left_h==-1 || right_h == -1)
        return -1;
    if(abs(left_h-right_h)>1)
        return -1;
    return max(left_h, right_h) + 1;
}

####################### Maximum Path Sum ######################################################

So we have to take any possible path and get the maximum sum, it contains negatives
Note: Kuch cases me negative aayega total weights to uss case me 0 return kro so that it is not included in answer
      baaki ek dum same as diameter, bass usme 1 + max(l,r) krte h 
Naive appraoch is to do a dfs and call height function at each node and checking the condition
O(N*N)

int fun(int &ans, TreeNode *root){
    if(root==NULL)return 0;
    int l = fun(ans, root->left);
    int r = fun(ans, root->right);

    ans = max(ans, root->val + l + r;);
    int curr_path_sum = max(l,r) + root->val;
    return curr_path_sum>=0?curr_path_sum:0;
}


####################### Symmetric tree ######################################################

Simple hi h, bass we have 3 conditions, that value must be same and the structure must be same.

bool isSameTree(TreeNode* p, TreeNode* q) {
    if(p==NULL || q==NULL)return p==q;
    if(p->val!=q->val)return false;
    bool l = isSameTree(p->left, q->left);
    bool r = isSameTree(p->right, q->right);
    return l&&r;
}


########################## Boundary Traversal ###############################################
1 - Left wale, so simple while me left kre chale jao (Jab tak left and right null na ho and leaf na lo)
2 - Leaf only except the boundary, so isme BFS types kro and bass condition laga do ki left and right null
    In this we cant do the Level Order beacuse different level pe hongi leaves
3 - Reverse me extreme right me jate hue and me add kro (Right nhi h to left m jao)

now just return the answer.


########################## Vertical Traversal ###############################################

If same level then lower value first - Nice QUESTION, AB aa gya samajh khud se krke

class Solution {
public:
    vector<vector<int>> verticalTraversal(TreeNode* root) {
        // Vertical, level, multiple nodes
        map<int,map<int,multiset<int>>> mp;

        // node, vertical level, level 
        queue<tuple<TreeNode*, int,int>> q;
        q.push({root,0,0});

        while(q.size()){
            auto [curr, v, level] = q.front();
            q.pop();

            // Adding to map...
            mp[v][level].insert(curr->val);
            if(curr->left){
                q.push({curr->left, v-1, level+1});
            }
            if(curr->right){
                q.push({curr->right, v+1, level+1});
            }
        }

        vector<vector<int>> ans;
        for(auto it:mp){
            vector<int> temp;
            for(auto i:it.second){
                for(auto elem:i.second){
                    temp.push_back(elem);
                }
            }
            ans.push_back(temp);
        }
        return ans;
    }
};

            
########################### TopView | BottomView Traversal ###############################################

Recursion wont work simply, we have to take care of height also. bcz right wale pe jayenge and vo baad me ho jayega append
vector<int> topView(Node *root)
{
    map<int,int> mp;
    queue<pair<Node*, int>> q;
    q.push({root, 0});
    
    while(q.size()){
        int v = q.front().second;
        Node* curr = q.front().first;
        q.pop();
        if(mp.find(v)==mp.end()){
            mp[v] = curr->data;
        }
        // To create Bottom View...
        // else{
        //    mp[v] = curr->data;
        // }
        if(curr->left){
            q.push({curr->left,v-1});
        }
        if(curr->right){
            q.push({curr->right,v+1});
        }
    }
    vector<int> ans;
    for(auto it:mp){
        ans.push_back(it.second);
    }
    return ans;
}


########################## RightView | LeftView Traversal ###############################################

Do a  Level order traversal and last node or start node is added to answer
TC: O(N), SC: O(N)

Do a recursive traversal and pass node, and level in the function

void fun(TreeNode* root, int level, vector<int>& res){
    if(root == NULL){
        return;
    }
    
    if(res.size() == level){
        res.push_back(root->val);
    }
    // Left View
    // else{
    //    res[level] = root->val;
    // }
    fun(root->left, level + 1, res);
    fun(root->right, level + 1, res);
}


##################### Is Symmetric Tree #######################################
Similar to camparing 2 tree wala ques 
But the difference is in this we call 
f(p->right, q->left) 
f(p->left, q->right)




##################### Print All Paths #######################################

Important... note when we are pushing and popping only once as we are pushing only once..

void fun(Node *root, vector<int> &temp, vector<vector<int>>&ans){
	if(root==NULL){
			return;
	}
	temp.push_back(root->data);
	if(root->left==NULL && root->right==NULL){
			ans.push_back(temp);
			temp.pop_back();
			return;
	}
	fun(root->left, temp, ans);
	fun(root->right, temp, ans);
	temp.pop_back();
}



##################### Print All Paths #######################################

Important...Same as BST, where as in BST we can add logic to search using its property...

bool fun(TreeNode *root, TreeNode* &ans, TreeNode *p, TreeNode * q){
		if(root==NULL)return false;
		if(root==p || root==q){
				ans = root;
				return true;
		}
		bool b1 = fun(root->left, ans, p,q);
		bool b2 = fun(root->right, ans,p,q);
		if(b1 && b2){
				ans = root;
				return true;
		}
		return b1|| b2;
}

##################### Width of Binary Tree #######################################

=> It means all the width of tree if we consider that from left most and right nost leaf we have 
	tree like a complete tree.

=> I was thinking of creating index like, 
 0 
 1 2
 3 4 5 6 
now if we have 3 and 5th nodes present so the ans would be 5-3+1 = 3 width but this in overflowing in Long Long also

=> Think of level order traversal.
=> So to over come just try to start from 0 each time in a traversal. 

int widthOfBinaryTree(TreeNode* root) {
		if(root==NULL)return 0;
		queue<pair<TreeNode*,long>> q;
		q.push({root,0});

		int ans = 0;
		while(!q.empty()){
				int size = q.size();
				long start_no;
				for(int i = 0;i<size;i++){
						TreeNode* curr= q.front().first;
						long node_no = q.front().second;
						q.pop();
						if(i==0){
								start_no = node_no;
						}
						node_no-=start_no; // This is important to overcome the problem of overflowing
						if(i==size-1){
								ans = max(ans, int(node_no+1));
						}
						if(curr->left){
								q.push({curr->left, 2*node_no + 1});
						}
						if(curr->right){
								q.push({curr->right, 2*node_no + 2});
						}
				}
		}
		return ans;
}
