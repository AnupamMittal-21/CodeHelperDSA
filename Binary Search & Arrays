Simple BS 
Lower Bound : Vo elem jo X se just chota h ya X h, so chote wale me ans = mid krdo
Upper Bound : Vo elem jo X se just bada h ya X h, bade wale case me and = mid krdo 


################## Find the first and last occuracnce of element in array ####################
So we implement lowerbound
  and we sbtract for x+1 wala lower bound 
nice...

class Solution {
private:
    int lower_bound(vector<int>& nums, int low, int high, int target){
        while(low <= high){
            int mid = (low + high) >> 1;
            if(nums[mid] < target){
                low = mid + 1;
            }
            else{
                high = mid - 1;
            }
        }
        return low;
    }
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        int low = 0, high = nums.size()-1;
        int startingPosition = lower_bound(nums, low, high, target);
        int endingPosition = lower_bound(nums, low, high, target + 1) - 1;
        if(startingPosition < nums.size() && nums[startingPosition] == target){
            return {startingPosition, endingPosition};
        }
        return {-1, -1};
    }
};


#############################################################################################
############################################################################################
############################# Rotation Based question on sorted array ######################

Search in Rotated : 

class Solution {
public:
    int search(std::vector<int>& nums, int target) {
        int low = 0, high = nums.size() - 1;

        while (low <= high) {
            int mid = (low + high) / 2;

            if (nums[mid] == target) {
                return mid;
            }

            if (nums[low] <= nums[mid]) {
                if (nums[low] <= target && target < nums[mid]) {
                    high = mid - 1;
                } else {
                    low = mid + 1;
                }
            } else {
                if (nums[mid] < target && target <= nums[high]) {
                    low = mid + 1;
                } else {
                    high = mid - 1;
                }
            }
        }

        return -1;
    }
};

########## Search in rotated 2 (Having Duplicates) ##########################

bool search(vector<int>& nums, int target) {
		int n = nums.size();
		int l = 0, r = n-1;
		while(l<=r){
				int mid = l + (r-l)/2;
				if(nums[mid] == target)return true;
				if(nums[l]==nums[mid]&& nums[mid]==nums[r]) {
						l++;
						r--;
						continue;
				}
				if(nums[mid]>=nums[l]){
						// Sorted is left...
						if(target<=nums[mid] && target>=nums[l]){
								r = mid - 1;
						}
						else{
								l = mid+1;
						}
				}
				else{
						// Sorted is right...
						if(target>=nums[mid] && target<=nums[r]){
								l = mid + 1;
						}
						else{
								r = mid-1;
						}
				}
		}
		return false;
}

//// isme jab mid and low and high equal h to hm decide nhi kr payenge ki kaha jaana h to uss case me l++, r-- krdo baki same h


############################## Finding Peak Element ##########################################

int findPeakElement(vector<int>& nums) {
        int start = nums[0];
        int l = 0, r = nums.size()-1;
        int n = nums.size();
        while(l<r){ // Boundarys ko consider krne ke liye
            int mid = (l+r)/2;
            if(nums[mid]<nums[mid+1]){
                l = mid+1; // kyuki mid to chota h to ye ans nhi ho sakta
            }
            else{
                r = mid; // mid bada h to ye and ho sakta h isiliye MID pe raho
            }
        }
        return l;
        
    }

Finding Peak in 2D arrat
Brute : scan each elem and check for 4 nighbour : n*m*4  => worst case
so we can only optimiset the worst case scenario... 

Better : find the largest one = m*n for best, avg 

BS me skip krenge kuch part ko 


left bada h mid se left me peak hoga
right bada h mid se to right me peak hoga 
aur agr mid bada h left and right se to vo ans h

vector<int> findPeakGrid(vector<vector<int>>& nums) {
		int l = 0;
		int r = nums.size()-1;
		int n = nums.size();

		while(l<=r){
				int mid = (l+r)/2;
				int maxIdx = findMax(nums[mid]);
				int left = mid-1>=0?nums[mid-1][maxIdx]:-1;
				int right = mid+1<n?nums[mid+1][maxIdx]:-1;
				int curr = nums[mid][maxIdx];
				if(curr>left && curr>right)return {mid, maxIdx};
				else if(curr<left){
						r = mid-1;
				}
				else{
						l = mid + 1;
				}
		}
		return {-1,-1};
}

############################## Minimum in rotated sorted array ############################
imp baat, l < r tak chalo 
2 - mid and end ko compare kro 

int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size()-1;
        while(left<right){
            int m = (right+left)/2;
            if(nums[m]<nums[right]){
                right=m;
            }
            else{
                left = m+1;
            }
        }
        return nums[left];
    }


#######################............BS ON ANSWERSS...........###################################
isme ye h ki -1 and N index = -INF so vo bhi ans me ho sakte h, aur mutliple Peak ho sakte h
to kahi bhi converge kro 
################ This is the Pattern for BS on answers ########################################

See isme kya identification h : Maximise the minimum OR Minimise the maximum 

This ques is similar to 
1 - Book allocation, ki array h to subarray le sakte h 
    and k students ko allot krna h such that sum is minimum unke beech me 

2 - Split Array Largest sum, so isme subarray lena h (k subarrays) such that sum jo ho subarray
    ka , unka jo maximum ho na, vo minimise ho sake
    so maximum sum ho sakta h sum of all elem, minimum hoga, mini element, so ye range ho gyi
    ab x sum minimum h to k ya k se jyada split wale subarray such that unka sum <= x h 
    to vo valid h 

3  - Capacity to ship package within D days, isme bhi subarray and sum h to ye bhi same h. isme 
    bhi  minimum wieght chaiye h 

4 - Painter's Partition Problem ye bhi same h ki ek number of painters h , 
    and nums[I] time h kitna lega ek painting ko ek paineter
    contiguous hi kr sakte h, to batao ki kitna minimum time lagega K painters ko... same....

5 - Minimum Number of Days to Make m Bouquets, ye bhi same h isme m boquet bano consecutive 
    flowers see , and minimum days chaiye h , days diye h array me 


bool helper(vector<int> &nums , int val, int days){
    int temp = val;
    int n = nums.size();
    int i = 0;
    while(i<n)
    {
        temp= val;
        if(nums[i]<=temp){
            while(i<n && nums[i]<=temp){
                temp-=nums[i];
                i++;
            }
            days--;
        }
        else{
            return false;
        }
    }
    
    return days>=0;
}
int splitArray(vector<int>& nums, int k) {
    int maxi = 0;
    for(auto it:nums){
        maxi+=it;
    }
    int l = 0;
    int r = maxi;

    while(l<=r){
        int mid = l + (r-l)/2;
        bool a = helper(nums, mid, k);
        cout<<mid<<" "<<a<<endl;
        if(a)
        {
            r = mid-1;
        }
        else{
            l = mid+1;
        }
    }
    return l;
}


######################### Aggressive Cow ##################################

bool checkCows(vector<int>&stalls,int mid,int Givencows){
	int cows=1;
	int lastPos=stalls[0];

	for(int i=1;i<stalls.size();i++){
		if(stalls[i]-lastPos>=mid){
			cows++;
			lastPos=stalls[i];	
		}
	}
	if(cows>=Givencows){
				return true;
	}
	return false;
}

int aggressiveCows(vector<int> &stalls, int k)
{
   int n=stalls.size();
	sort(stalls.begin(),stalls.end());// first we sort the array
	int l=0;
	int h=stalls[n-1]-stalls[0];// maximum element - minimum element this is max smallest distace we can take
	int res=-1;
	while(l<=h){
		int mid=l+(h-l)/2;
		if(checkCows(stalls,mid,k)){// if we are able to place k cows in mid distance
			res=mid;// store the answer
			l=mid+1;// check for max distance in the right 
		}
		else{
			h=mid-1;
		}
	}
	return res;
}





###################################### BS ON 2D arrays #####################################################

################### Row with max 1s

	ye interesting ques h as isme phle sorted h on each list, so hme max no of ones ka count batana h 
	now ism brute ho gy i n*m ki
	better ho gyi  nLogm
	best ho gyi n+m jo ki start kro topright see, 
	and vah se neeche chalo agr 0 aa gya to neeche, 1 h to left and left jate hue idx = i krdo


int bs(vector<int> &nums, int l, int r){
        int ans = nums.size();
        while(l<=r){
            int mid = l + (r-l)/2;
            if(nums[mid]==1){
                ans = mid;
                r = mid-1;
            }
            else{
                l = mid+1;
            }
        }
        return ans;
    }
    int rowWithMax1s(vector<vector<int> > arr) {
        // code here
        int n = arr.size();
        int m = arr[0].size();
        int l = 0;
        int r = m-1;
        int ans = m;
        int idx = -1;
        // for(int i = 0;i<n;i++){
        //     int mini = bs(arr[i], l,r);
        //     // cout<<mini<<" ";
        //     if(mini<ans){
        //         idx = i;
        //         ans = mini;
        //     }
        //     r = ans;
        // }
        // return idx;
        while(l<n && r>=0){
            if(arr[l][r]==1){
                r--;
                idx = l;
            }
            else{
                l++;
            }
        }
        return idx;        
    }


################# Search in 2D matrix ##########################3
ye case h ki element in next row is graeter then last element o previous row , tabhi hm vo log(n*m ) wala laga sakteh 

Brute is O(n*m)

Better is (n + logM) - harr row me jao and see if starting and ending ke beech me h target agar h 
to BS lagado uss row me
else neeche chalte rho 

Better : O(n + m) start from top right element, and start from there and if elem is greater than the curr elem then go to left
else go down, so n + m chalenge 

Best: O(log(n*m)) : to isme assume ki n*m ki flatten h to simplt BS lagao ,and row = mid/cols , col = mid%ccols

bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = matrix.size();
        int col = matrix[0].size();

        int start = 0;
        // because we are thinking it as linear array (sorted already)
        int end = (row*col) - 1;
        int mid = start + (end - start)/2;
        while(start <= end){
            int element = matrix[mid / col][mid % col];
            if(element == target){
                return true;
            }
            if(element < target){
                start = mid + 1;
            }
            else{
                end = mid - 1;
            }
            mid = start + (end - start)/2;
        }
        return false;
    }



################## Search in 2d part 2 ##########################

Better : isme n + log m nhi lagega kyuki multiple rows ho sakti h jisme vo lie kre
		so n * log m hoga better solution 
Best : isme column wise and row wise sorted h to o(n+m) 

bool searchMatrix(vector<vector<int>>& nums, int target) {
        int n = nums.size(), m = nums[0].size();
        int i = 0, j = m-1;

        while(i<n && j>=0){
            if(nums[i][j] == target){
                return true;
            }
            else if(nums[i][j]>target){
                j--;
            }
            else{
                i++;
            }
        }
        return false;
    }


Median in 2d 

BRUTE : 1d me daalo , sort kro and middle nikal lo 
